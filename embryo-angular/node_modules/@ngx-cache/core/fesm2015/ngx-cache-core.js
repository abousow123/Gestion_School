import { InjectionToken, ɵɵinject, PLATFORM_ID, Injector, ɵɵdefineInjectable, ɵsetClassMetadata, Injectable, Inject, ɵɵdefineNgModule, ɵɵdefineInjector, NgModule, Optional, SkipSelf } from '@angular/core';
import { of } from 'rxjs';
import { map } from 'rxjs/operators';
import { EventEmitter } from 'events';

class Cache {
}

class CacheLoader {
}
class CacheStaticLoader {
    constructor(providedSettings = {
        key: 'NGX_CACHE',
        lifeSpan: {
            expiry: Number.MAX_VALUE,
            TTL: Number.MAX_VALUE
        }
    }) {
        this.providedSettings = providedSettings;
    }
    get key() {
        return this.providedSettings.key;
    }
    get lifeSpan() {
        return this.providedSettings.lifeSpan;
    }
}

var ReturnType;
(function (ReturnType) {
    ReturnType[ReturnType["Scalar"] = 0] = "Scalar";
    ReturnType[ReturnType["Observable"] = 10] = "Observable";
    ReturnType[ReturnType["Promise"] = 20] = "Promise";
})(ReturnType || (ReturnType = {}));

const CACHE = new InjectionToken('CACHE');
class CacheService {
    constructor(loader, platformId, injector) {
        this.loader = loader;
        this.platformId = platformId;
        this.injector = injector;
        CacheService.instance = this;
        this.cache = this.injector.get(CACHE);
        this.lifeSpan = loader.lifeSpan;
    }
    static getInstance(loader, platformId, injector) {
        return CacheService.instance;
    }
    static normalizeKey(key) {
        if (CacheService.validateKey(key)) {
            throw new Error('Please provide a valid key to save in the CacheService');
        }
        return `${key}`;
    }
    static validateKey(key) {
        return !key || typeof key === 'boolean' || Number.isNaN(key);
    }
    static validateValue(value) {
        return value.lifeSpan.expiry && value.lifeSpan.expiry > Date.now();
    }
    get key() {
        return this.loader.key;
    }
    has(key) {
        const normalized = CacheService.normalizeKey(key);
        return this.cache.keys.indexOf(normalized) !== -1 && CacheService.validateValue(this.cache.getItem(normalized));
    }
    set(key, value, returnType = ReturnType.Scalar, lifeSpan) {
        const normalized = CacheService.normalizeKey(key);
        return this.cache.setItem(normalized, {
            data: value,
            returnType,
            lifeSpan: this.parseLifeSpan(lifeSpan ? lifeSpan : this.lifeSpan)
        });
    }
    get(key) {
        const normalized = CacheService.normalizeKey(key);
        const cached = this.cache.getItem(normalized);
        if (Object.entries(cached).length !== 0 && cached.constructor === Object) {
            if (CacheService.validateValue(cached)) {
                return cached.data;
            }
            this.remove(normalized);
        }
        return undefined;
    }
    getWithMetadata(key) {
        const normalized = CacheService.normalizeKey(key);
        const cached = this.cache.getItem(normalized);
        if (Object.entries(cached).length !== 0 && cached.constructor === Object) {
            if (CacheService.validateValue(cached)) {
                return cached;
            }
            this.remove(key);
        }
        return undefined;
    }
    remove(key, wild = false) {
        const normalized = CacheService.normalizeKey(key);
        this.cache.removeItem(normalized, wild);
    }
    clear() {
        this.cache.clear();
    }
    dehydrate() {
        const keys = this.cache.keys.length ? this.cache.keys : [];
        const res = {};
        keys.forEach((key) => {
            res[key] = this.cache.getItem(key);
        });
        return res;
    }
    rehydrate(json) {
        Object.keys(json).forEach((key) => {
            const normalized = CacheService.normalizeKey(key);
            this.cache.setItem(normalized, json[normalized]);
        });
    }
    parseLifeSpan(lifeSpan) {
        return {
            expiry: lifeSpan.expiry || (lifeSpan.TTL ? Date.now() + lifeSpan.TTL * 1000 : this.lifeSpan.expiry),
            TTL: lifeSpan.TTL || this.lifeSpan.TTL
        };
    }
}
CacheService.instance = undefined;
CacheService.ɵfac = function CacheService_Factory(t) { return new (t || CacheService)(ɵɵinject(CacheLoader), ɵɵinject(PLATFORM_ID), ɵɵinject(Injector)); };
CacheService.ɵprov = ɵɵdefineInjectable({ token: CacheService, factory: CacheService.ɵfac });
(function () { ɵsetClassMetadata(CacheService, [{
        type: Injectable
    }], function () { return [{ type: CacheLoader }, { type: undefined, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }, { type: Injector }]; }, null); })();

const STORAGE = new InjectionToken('STORAGE');
const cacheFactory = () => new CacheStaticLoader();
const cacheServiceFactory = (loader, platformId, injector) => new CacheService(loader, platformId, injector);
class CacheModule {
    constructor(parentModule) {
        if (parentModule) {
            throw new Error('CacheModule already loaded; import in root module only.');
        }
    }
    static forRoot(configuredProvider = {
        provide: CacheLoader,
        useFactory: cacheFactory
    }) {
        return {
            ngModule: CacheModule,
            providers: [
                configuredProvider,
                {
                    provide: CacheService,
                    useFactory: cacheServiceFactory,
                    deps: [CacheLoader, PLATFORM_ID, Injector]
                }
            ]
        };
    }
}
CacheModule.ɵmod = ɵɵdefineNgModule({ type: CacheModule });
CacheModule.ɵinj = ɵɵdefineInjector({ factory: function CacheModule_Factory(t) { return new (t || CacheModule)(ɵɵinject(CacheModule, 12)); } });
(function () { ɵsetClassMetadata(CacheModule, [{
        type: NgModule
    }], function () { return [{ type: CacheModule, decorators: [{
                type: Optional
            }, {
                type: SkipSelf
            }] }]; }, null); })();

const isPromise = (obj) => !!obj && typeof obj.then === 'function';
const isObservable = (obj) => !!obj && typeof obj.subscribe === 'function';

function CacheKey(target, propertyKey, index) {
    const metadataKey = `__cache_${propertyKey}_keys`;
    Array.isArray(target[metadataKey]) ? target[metadataKey].push(index) : (target[metadataKey] = [index]);
}
function Cached(key) {
    return function (target, propertyKey, descriptor) {
        const method = descriptor.value;
        descriptor.value = function (...args) {
            const cache = CacheService.getInstance();
            const metadataKey = `__cache_${propertyKey}_keys`;
            const indices = target[metadataKey];
            let keyParts = '';
            if (Array.isArray(indices)) {
                for (let i = 0; i < args.length; i++) {
                    if (indices.indexOf(i) !== -1) {
                        keyParts = !keyParts ? String(args[i]) : `${keyParts}_${String(args[i])}`;
                    }
                }
            }
            let cacheKey = !keyParts ? key : `${key}_${keyParts}`;
            cacheKey = CacheService.normalizeKey(cacheKey);
            if (!cache || !cacheKey) {
                return method.apply(this, args);
            }
            if (cache.has(cacheKey)) {
                const cached = cache.getWithMetadata(cacheKey);
                if (cached && cached.data) {
                    switch (cached.returnType) {
                        case ReturnType.Observable:
                            return of(cached.data);
                        case ReturnType.Promise:
                            return Promise.resolve(cached.data);
                        default:
                            return cached.data;
                    }
                }
            }
            const value = method.apply(this, args);
            if (isObservable(value)) {
                return value.pipe(map((res) => {
                    cache.set(cacheKey, res, ReturnType.Observable);
                    return res;
                }));
            }
            else if (isPromise(value)) {
                return (value).then((res) => {
                    cache.set(cacheKey, res, ReturnType.Promise);
                    return res;
                });
            }
            cache.set(cacheKey, value);
            return value;
        };
        return descriptor;
    };
}

class Storage extends EventEmitter {
}

export { CACHE, Cache, CacheKey, CacheLoader, CacheModule, CacheService, CacheStaticLoader, Cached, STORAGE, Storage, cacheFactory, cacheServiceFactory };
//# sourceMappingURL=ngx-cache-core.js.map
