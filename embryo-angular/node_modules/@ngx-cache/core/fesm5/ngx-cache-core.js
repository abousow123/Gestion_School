import { InjectionToken, ɵɵinject, PLATFORM_ID, Injector, ɵɵdefineInjectable, ɵsetClassMetadata, Injectable, Inject, ɵɵdefineNgModule, ɵɵdefineInjector, NgModule, Optional, SkipSelf } from '@angular/core';
import { of } from 'rxjs';
import { map } from 'rxjs/operators';
import { __extends } from 'tslib';
import { EventEmitter } from 'events';

var Cache = (function () {
    function Cache() {
    }
    return Cache;
}());

var CacheLoader = (function () {
    function CacheLoader() {
    }
    return CacheLoader;
}());
var CacheStaticLoader = (function () {
    function CacheStaticLoader(providedSettings) {
        if (providedSettings === void 0) { providedSettings = {
            key: 'NGX_CACHE',
            lifeSpan: {
                expiry: Number.MAX_VALUE,
                TTL: Number.MAX_VALUE
            }
        }; }
        this.providedSettings = providedSettings;
    }
    Object.defineProperty(CacheStaticLoader.prototype, "key", {
        get: function () {
            return this.providedSettings.key;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CacheStaticLoader.prototype, "lifeSpan", {
        get: function () {
            return this.providedSettings.lifeSpan;
        },
        enumerable: true,
        configurable: true
    });
    return CacheStaticLoader;
}());

var ReturnType;
(function (ReturnType) {
    ReturnType[ReturnType["Scalar"] = 0] = "Scalar";
    ReturnType[ReturnType["Observable"] = 10] = "Observable";
    ReturnType[ReturnType["Promise"] = 20] = "Promise";
})(ReturnType || (ReturnType = {}));

var CACHE = new InjectionToken('CACHE');
var CacheService = (function () {
    function CacheService(loader, platformId, injector) {
        this.loader = loader;
        this.platformId = platformId;
        this.injector = injector;
        CacheService.instance = this;
        this.cache = this.injector.get(CACHE);
        this.lifeSpan = loader.lifeSpan;
    }
    CacheService.getInstance = function (loader, platformId, injector) {
        return CacheService.instance;
    };
    CacheService.normalizeKey = function (key) {
        if (CacheService.validateKey(key)) {
            throw new Error('Please provide a valid key to save in the CacheService');
        }
        return "" + key;
    };
    CacheService.validateKey = function (key) {
        return !key || typeof key === 'boolean' || Number.isNaN(key);
    };
    CacheService.validateValue = function (value) {
        return value.lifeSpan.expiry && value.lifeSpan.expiry > Date.now();
    };
    Object.defineProperty(CacheService.prototype, "key", {
        get: function () {
            return this.loader.key;
        },
        enumerable: true,
        configurable: true
    });
    CacheService.prototype.has = function (key) {
        var normalized = CacheService.normalizeKey(key);
        return this.cache.keys.indexOf(normalized) !== -1 && CacheService.validateValue(this.cache.getItem(normalized));
    };
    CacheService.prototype.set = function (key, value, returnType, lifeSpan) {
        if (returnType === void 0) { returnType = ReturnType.Scalar; }
        var normalized = CacheService.normalizeKey(key);
        return this.cache.setItem(normalized, {
            data: value,
            returnType: returnType,
            lifeSpan: this.parseLifeSpan(lifeSpan ? lifeSpan : this.lifeSpan)
        });
    };
    CacheService.prototype.get = function (key) {
        var normalized = CacheService.normalizeKey(key);
        var cached = this.cache.getItem(normalized);
        if (Object.entries(cached).length !== 0 && cached.constructor === Object) {
            if (CacheService.validateValue(cached)) {
                return cached.data;
            }
            this.remove(normalized);
        }
        return undefined;
    };
    CacheService.prototype.getWithMetadata = function (key) {
        var normalized = CacheService.normalizeKey(key);
        var cached = this.cache.getItem(normalized);
        if (Object.entries(cached).length !== 0 && cached.constructor === Object) {
            if (CacheService.validateValue(cached)) {
                return cached;
            }
            this.remove(key);
        }
        return undefined;
    };
    CacheService.prototype.remove = function (key, wild) {
        if (wild === void 0) { wild = false; }
        var normalized = CacheService.normalizeKey(key);
        this.cache.removeItem(normalized, wild);
    };
    CacheService.prototype.clear = function () {
        this.cache.clear();
    };
    CacheService.prototype.dehydrate = function () {
        var _this = this;
        var keys = this.cache.keys.length ? this.cache.keys : [];
        var res = {};
        keys.forEach(function (key) {
            res[key] = _this.cache.getItem(key);
        });
        return res;
    };
    CacheService.prototype.rehydrate = function (json) {
        var _this = this;
        Object.keys(json).forEach(function (key) {
            var normalized = CacheService.normalizeKey(key);
            _this.cache.setItem(normalized, json[normalized]);
        });
    };
    CacheService.prototype.parseLifeSpan = function (lifeSpan) {
        return {
            expiry: lifeSpan.expiry || (lifeSpan.TTL ? Date.now() + lifeSpan.TTL * 1000 : this.lifeSpan.expiry),
            TTL: lifeSpan.TTL || this.lifeSpan.TTL
        };
    };
    CacheService.instance = undefined;
    CacheService.ɵfac = function CacheService_Factory(t) { return new (t || CacheService)(ɵɵinject(CacheLoader), ɵɵinject(PLATFORM_ID), ɵɵinject(Injector)); };
    CacheService.ɵprov = ɵɵdefineInjectable({ token: CacheService, factory: CacheService.ɵfac });
    return CacheService;
}());
(function () { ɵsetClassMetadata(CacheService, [{
        type: Injectable
    }], function () { return [{ type: CacheLoader }, { type: undefined, decorators: [{
                type: Inject,
                args: [PLATFORM_ID]
            }] }, { type: Injector }]; }, null); })();

var STORAGE = new InjectionToken('STORAGE');
var cacheFactory = function () { return new CacheStaticLoader(); };
var cacheServiceFactory = function (loader, platformId, injector) {
    return new CacheService(loader, platformId, injector);
};
var CacheModule = (function () {
    function CacheModule(parentModule) {
        if (parentModule) {
            throw new Error('CacheModule already loaded; import in root module only.');
        }
    }
    CacheModule.forRoot = function (configuredProvider) {
        if (configuredProvider === void 0) { configuredProvider = {
            provide: CacheLoader,
            useFactory: cacheFactory
        }; }
        return {
            ngModule: CacheModule,
            providers: [
                configuredProvider,
                {
                    provide: CacheService,
                    useFactory: cacheServiceFactory,
                    deps: [CacheLoader, PLATFORM_ID, Injector]
                }
            ]
        };
    };
    CacheModule.ɵmod = ɵɵdefineNgModule({ type: CacheModule });
    CacheModule.ɵinj = ɵɵdefineInjector({ factory: function CacheModule_Factory(t) { return new (t || CacheModule)(ɵɵinject(CacheModule, 12)); } });
    return CacheModule;
}());
(function () { ɵsetClassMetadata(CacheModule, [{
        type: NgModule
    }], function () { return [{ type: CacheModule, decorators: [{
                type: Optional
            }, {
                type: SkipSelf
            }] }]; }, null); })();

var isPromise = function (obj) { return !!obj && typeof obj.then === 'function'; };
var isObservable = function (obj) { return !!obj && typeof obj.subscribe === 'function'; };

function CacheKey(target, propertyKey, index) {
    var metadataKey = "__cache_" + propertyKey + "_keys";
    Array.isArray(target[metadataKey]) ? target[metadataKey].push(index) : (target[metadataKey] = [index]);
}
function Cached(key) {
    return function (target, propertyKey, descriptor) {
        var method = descriptor.value;
        descriptor.value = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var cache = CacheService.getInstance();
            var metadataKey = "__cache_" + propertyKey + "_keys";
            var indices = target[metadataKey];
            var keyParts = '';
            if (Array.isArray(indices)) {
                for (var i = 0; i < args.length; i++) {
                    if (indices.indexOf(i) !== -1) {
                        keyParts = !keyParts ? String(args[i]) : keyParts + "_" + String(args[i]);
                    }
                }
            }
            var cacheKey = !keyParts ? key : key + "_" + keyParts;
            cacheKey = CacheService.normalizeKey(cacheKey);
            if (!cache || !cacheKey) {
                return method.apply(this, args);
            }
            if (cache.has(cacheKey)) {
                var cached = cache.getWithMetadata(cacheKey);
                if (cached && cached.data) {
                    switch (cached.returnType) {
                        case ReturnType.Observable:
                            return of(cached.data);
                        case ReturnType.Promise:
                            return Promise.resolve(cached.data);
                        default:
                            return cached.data;
                    }
                }
            }
            var value = method.apply(this, args);
            if (isObservable(value)) {
                return value.pipe(map(function (res) {
                    cache.set(cacheKey, res, ReturnType.Observable);
                    return res;
                }));
            }
            else if (isPromise(value)) {
                return (value).then(function (res) {
                    cache.set(cacheKey, res, ReturnType.Promise);
                    return res;
                });
            }
            cache.set(cacheKey, value);
            return value;
        };
        return descriptor;
    };
}

var Storage = (function (_super) {
    __extends(Storage, _super);
    function Storage() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Storage;
}(EventEmitter));

export { CACHE, Cache, CacheKey, CacheLoader, CacheModule, CacheService, CacheStaticLoader, Cached, STORAGE, Storage, cacheFactory, cacheServiceFactory };
//# sourceMappingURL=ngx-cache-core.js.map
