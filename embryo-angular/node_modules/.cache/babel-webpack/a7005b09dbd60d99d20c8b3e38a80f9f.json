{"ast":null,"code":"import noop from 'lodash/noop';\nimport { checkRendering, parseAroundLatLngFromString } from '../../lib/utils';\nvar usage = 'Usage:\\n\\nvar customGeoSearch = connectGeoSearch(function render(params, isFirstRendering) {\\n  // params = {\\n  //   items,\\n  //   position,\\n  //   refine,\\n  //   clearMapRefinement,\\n  //   isRefinedWithMap,\\n  //   toggleRefineOnMapMove,\\n  //   isRefineOnMapMove,\\n  //   setMapMoveSinceLastRefine,\\n  //   hasMapMoveSinceLastRefine,\\n  //   hasMapMoveSinceLastRefine,\\n  //   widgetParams,\\n  //   instantSearchInstance,\\n  // }\\n});\\n\\nsearch.addWidget(\\n  customGeoSearch({\\n    [ enableRefineOnMapMove = true ],\\n    [ enableGeolocationWithIP = true ],\\n    [ position ],\\n    [ radius ],\\n    [ precision ],\\n    [ transformItems ],\\n  })\\n);\\n\\nFull documentation available at https://community.algolia.com/instantsearch.js/v2/connectors/connectGeoSearch.html\\n';\n/**\n * @typedef {Object} LatLng\n * @property {number} lat The latitude in degrees.\n * @property {number} lng The longitude in degrees.\n */\n\n/**\n * @typedef {Object} Bounds\n * @property {LatLng} northEast The top right corner of the map view.\n * @property {LatLng} southWest The bottom left corner of the map view.\n */\n\n/**\n * @typedef {Object} CustomGeoSearchWidgetOptions\n * @property {boolean} [enableRefineOnMapMove=true] If true, refine will be triggered as you move the map.\n * @property {boolean} [enableGeolocationWithIP=true] If true, the IP will be use for the geolocation. When the `position` option is provided this option will be ignored. See [the documentation](https://www.algolia.com/doc/api-reference/api-parameters/aroundLatLngViaIP) for more information.\n * @property {LatLng} [position] Position that will be use to search around. <br />\n * See [the documentation](https://www.algolia.com/doc/api-reference/api-parameters/aroundLatLng) for more information.\n * @property {number} [radius] Maximum radius to search around the position (in meters). <br />\n * See [the documentation](https://www.algolia.com/doc/api-reference/api-parameters/aroundRadius) for more information.\n * @property {number} [precision] Precision of geo search (in meters). <br />\n * See [the documentation](https://www.algolia.com/doc/api-reference/api-parameters/aroundPrecision) for more information.\n * @property {function(object[]):object[]} [transformItems] Function to transform the items passed to the templates.\n */\n\n/**\n * @typedef {Object} GeoSearchRenderingOptions\n * @property {Object[]} items The matched hits from Algolia API.\n * @property {function(Bounds)} refine Sets a bounding box to filter the results from the given map bounds.\n * @property {function()} clearMapRefinement Reset the current bounding box refinement.\n * @property {function(): boolean} isRefinedWithMap Return true if the current refinement is set with the map bounds.\n * @property {function()} toggleRefineOnMapMove Toggle the fact that the user is able to refine on map move.\n * @property {function(): boolean} isRefineOnMapMove Return true if the user is able to refine on map move.\n * @property {function()} setMapMoveSinceLastRefine Set the fact that the map has moved since the last refinement, should be call on each map move. The call to the function triggers a new rendering only when the value change.\n * @property {function(): boolean} hasMapMoveSinceLastRefine Return true if the map has move since the last refinement.\n * @property {Object} widgetParams All original `CustomGeoSearchWidgetOptions` forwarded to the `renderFn`.\n * @property {LatLng} [position] The current position of the search.\n */\n\n/**\n * The **GeoSearch** connector provides the logic to build a widget that will display the results on a map. It also provides a way to search for results based on their position. The connector provides functions to manage the search experience (search on map interaction or control the interaction for example).\n *\n * @requirements\n *\n * Note that the GeoSearch connector uses the [geosearch](https://www.algolia.com/doc/guides/searching/geo-search) capabilities of Algolia. Your hits **must** have a `_geoloc` attribute in order to be passed to the rendering function.\n *\n * Currently, the feature is not compatible with multiple values in the _geoloc attribute.\n *\n * @type {Connector}\n * @canonical https://www.algolia.com/doc/api-reference/widgets/geo-search/js/\n * @param {function(GeoSearchRenderingOptions, boolean)} renderFn Rendering function for the custom **GeoSearch** widget.\n * @param {function} unmountFn Unmount function called when the widget is disposed.\n * @return {function(CustomGeoSearchWidgetOptions)} Re-usable widget factory for a custom **GeoSearch** widget.\n * @staticExample\n * // This example use Leaflet for the rendering, be sure to have the library correctly setup\n * // before trying the demo. You can find more details in their documentation (link below).\n * // We choose Leaflet for the example but you can use any libraries that you want.\n * // See: http://leafletjs.com/examples/quick-start\n *\n * let map = null;\n * let markers = [];\n *\n * // custom `renderFn` to render the custom GeoSearch widget\n * function renderFn(GeoSearchRenderingOptions, isFirstRendering) {\n *   const { items, widgetParams } = GeoSearchRenderingOptions;\n *\n *   if (isFirstRendering) {\n *     map = L.map(widgetParams.container);\n *\n *     L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n *       attribution:\n *         '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors',\n *     }).addTo(map);\n *   }\n *\n *   markers.forEach(marker => marker.remove());\n *\n *   markers = items.map(({ _geoloc }) =>\n *     L.marker([_geoloc.lat, _geoloc.lng]).addTo(map)\n *   );\n *\n *   if (markers.length) {\n *     map.fitBounds(L.featureGroup(markers).getBounds());\n *   }\n * }\n *\n * // connect `renderFn` to GeoSearch logic\n * const customGeoSearch = instantsearch.connectors.connectGeoSearch(renderFn);\n *\n * // mount widget on the page\n * search.addWidget(\n *   customGeoSearch({\n *     container: document.getElementById('custom-geo-search'),\n *   })\n * );\n */\n\nvar connectGeoSearch = function connectGeoSearch(renderFn, unmountFn) {\n  checkRendering(renderFn, usage);\n  return function () {\n    var widgetParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var _widgetParams$enableR = widgetParams.enableRefineOnMapMove,\n        enableRefineOnMapMove = _widgetParams$enableR === undefined ? true : _widgetParams$enableR,\n        _widgetParams$enableG = widgetParams.enableGeolocationWithIP,\n        enableGeolocationWithIP = _widgetParams$enableG === undefined ? true : _widgetParams$enableG,\n        position = widgetParams.position,\n        radius = widgetParams.radius,\n        precision = widgetParams.precision,\n        _widgetParams$transfo = widgetParams.transformItems,\n        transformItems = _widgetParams$transfo === undefined ? function (items) {\n      return items;\n    } : _widgetParams$transfo;\n    var widgetState = {\n      isRefineOnMapMove: enableRefineOnMapMove,\n      hasMapMoveSinceLastRefine: false,\n      lastRefinePosition: '',\n      lastRefineBoundingBox: '',\n      internalToggleRefineOnMapMove: noop,\n      internalSetMapMoveSinceLastRefine: noop\n    };\n\n    var getPositionFromState = function getPositionFromState(state) {\n      return state.aroundLatLng && parseAroundLatLngFromString(state.aroundLatLng);\n    };\n\n    var refine = function refine(helper) {\n      return function (_ref) {\n        var ne = _ref.northEast,\n            sw = _ref.southWest;\n        var boundingBox = [ne.lat, ne.lng, sw.lat, sw.lng].join();\n        helper.setQueryParameter('insideBoundingBox', boundingBox).search();\n        widgetState.hasMapMoveSinceLastRefine = false;\n        widgetState.lastRefineBoundingBox = boundingBox;\n      };\n    };\n\n    var clearMapRefinement = function clearMapRefinement(helper) {\n      return function () {\n        helper.setQueryParameter('insideBoundingBox').search();\n      };\n    };\n\n    var isRefinedWithMap = function isRefinedWithMap(state) {\n      return function () {\n        return Boolean(state.insideBoundingBox);\n      };\n    };\n\n    var toggleRefineOnMapMove = function toggleRefineOnMapMove() {\n      return widgetState.internalToggleRefineOnMapMove();\n    };\n\n    var createInternalToggleRefinementonMapMove = function createInternalToggleRefinementonMapMove(render, args) {\n      return function () {\n        widgetState.isRefineOnMapMove = !widgetState.isRefineOnMapMove;\n        render(args);\n      };\n    };\n\n    var isRefineOnMapMove = function isRefineOnMapMove() {\n      return widgetState.isRefineOnMapMove;\n    };\n\n    var setMapMoveSinceLastRefine = function setMapMoveSinceLastRefine() {\n      return widgetState.internalSetMapMoveSinceLastRefine();\n    };\n\n    var createInternalSetMapMoveSinceLastRefine = function createInternalSetMapMoveSinceLastRefine(render, args) {\n      return function () {\n        var shouldTriggerRender = widgetState.hasMapMoveSinceLastRefine !== true;\n        widgetState.hasMapMoveSinceLastRefine = true;\n\n        if (shouldTriggerRender) {\n          render(args);\n        }\n      };\n    };\n\n    var hasMapMoveSinceLastRefine = function hasMapMoveSinceLastRefine() {\n      return widgetState.hasMapMoveSinceLastRefine;\n    };\n\n    var init = function init(initArgs) {\n      var state = initArgs.state,\n          helper = initArgs.helper,\n          instantSearchInstance = initArgs.instantSearchInstance;\n      var isFirstRendering = true;\n      widgetState.internalToggleRefineOnMapMove = createInternalToggleRefinementonMapMove(noop, initArgs);\n      widgetState.internalSetMapMoveSinceLastRefine = createInternalSetMapMoveSinceLastRefine(noop, initArgs);\n      renderFn({\n        items: [],\n        position: getPositionFromState(state),\n        refine: refine(helper),\n        clearMapRefinement: clearMapRefinement(helper),\n        isRefinedWithMap: isRefinedWithMap(state),\n        toggleRefineOnMapMove: toggleRefineOnMapMove,\n        isRefineOnMapMove: isRefineOnMapMove,\n        setMapMoveSinceLastRefine: setMapMoveSinceLastRefine,\n        hasMapMoveSinceLastRefine: hasMapMoveSinceLastRefine,\n        widgetParams: widgetParams,\n        instantSearchInstance: instantSearchInstance\n      }, isFirstRendering);\n    };\n\n    var render = function render(renderArgs) {\n      var results = renderArgs.results,\n          helper = renderArgs.helper,\n          instantSearchInstance = renderArgs.instantSearchInstance;\n      var isFirstRendering = false; // We don't use the state provided by the render function because we need\n      // to be sure that the state is the latest one for the following condition\n\n      var state = helper.getState();\n      var positionChangedSinceLastRefine = Boolean(state.aroundLatLng) && Boolean(widgetState.lastRefinePosition) && state.aroundLatLng !== widgetState.lastRefinePosition;\n      var boundingBoxChangedSinceLastRefine = !state.insideBoundingBox && Boolean(widgetState.lastRefineBoundingBox) && state.insideBoundingBox !== widgetState.lastRefineBoundingBox;\n\n      if (positionChangedSinceLastRefine || boundingBoxChangedSinceLastRefine) {\n        widgetState.hasMapMoveSinceLastRefine = false;\n      }\n\n      widgetState.lastRefinePosition = state.aroundLatLng || '';\n      widgetState.lastRefineBoundingBox = state.insideBoundingBox || '';\n      widgetState.internalToggleRefineOnMapMove = createInternalToggleRefinementonMapMove(render, renderArgs);\n      widgetState.internalSetMapMoveSinceLastRefine = createInternalSetMapMoveSinceLastRefine(render, renderArgs);\n      var items = transformItems(results.hits.filter(function (hit) {\n        return hit._geoloc;\n      }));\n      renderFn({\n        items: items,\n        position: getPositionFromState(state),\n        refine: refine(helper),\n        clearMapRefinement: clearMapRefinement(helper),\n        isRefinedWithMap: isRefinedWithMap(state),\n        toggleRefineOnMapMove: toggleRefineOnMapMove,\n        isRefineOnMapMove: isRefineOnMapMove,\n        setMapMoveSinceLastRefine: setMapMoveSinceLastRefine,\n        hasMapMoveSinceLastRefine: hasMapMoveSinceLastRefine,\n        widgetParams: widgetParams,\n        instantSearchInstance: instantSearchInstance\n      }, isFirstRendering);\n    };\n\n    return {\n      init: init,\n      render: render,\n      getConfiguration: function getConfiguration(previous) {\n        var configuration = {};\n\n        if (enableGeolocationWithIP && !position && !previous.aroundLatLng && previous.aroundLatLngViaIP === undefined) {\n          configuration.aroundLatLngViaIP = true;\n        }\n\n        if (position && !previous.aroundLatLng && !previous.aroundLatLngViaIP) {\n          configuration.aroundLatLng = position.lat + ', ' + position.lng;\n        }\n\n        if (radius && !previous.aroundRadius) {\n          configuration.aroundRadius = radius;\n        }\n\n        if (precision && !previous.aroundPrecision) {\n          configuration.aroundPrecision = precision;\n        }\n\n        return configuration;\n      },\n      dispose: function dispose(_ref2) {\n        var state = _ref2.state;\n        unmountFn();\n        var nextState = state;\n\n        if (enableGeolocationWithIP && !position) {\n          nextState = nextState.setQueryParameter('aroundLatLngViaIP');\n        }\n\n        if (position) {\n          nextState = nextState.setQueryParameter('aroundLatLng');\n        }\n\n        if (radius) {\n          nextState = nextState.setQueryParameter('aroundRadius');\n        }\n\n        if (precision) {\n          nextState = nextState.setQueryParameter('aroundPrecision');\n        }\n\n        nextState = nextState.setQueryParameter('insideBoundingBox');\n        return nextState;\n      }\n    };\n  };\n};\n\nexport default connectGeoSearch;","map":{"version":3,"sources":["/home/sow/Bureau/ProjetPerso/Gestion_School/embryo-angular/node_modules/instantsearch.js/es/connectors/geo-search/connectGeoSearch.js"],"names":["noop","checkRendering","parseAroundLatLngFromString","usage","connectGeoSearch","renderFn","unmountFn","widgetParams","arguments","length","undefined","_widgetParams$enableR","enableRefineOnMapMove","_widgetParams$enableG","enableGeolocationWithIP","position","radius","precision","_widgetParams$transfo","transformItems","items","widgetState","isRefineOnMapMove","hasMapMoveSinceLastRefine","lastRefinePosition","lastRefineBoundingBox","internalToggleRefineOnMapMove","internalSetMapMoveSinceLastRefine","getPositionFromState","state","aroundLatLng","refine","helper","_ref","ne","northEast","sw","southWest","boundingBox","lat","lng","join","setQueryParameter","search","clearMapRefinement","isRefinedWithMap","Boolean","insideBoundingBox","toggleRefineOnMapMove","createInternalToggleRefinementonMapMove","render","args","setMapMoveSinceLastRefine","createInternalSetMapMoveSinceLastRefine","shouldTriggerRender","init","initArgs","instantSearchInstance","isFirstRendering","renderArgs","results","getState","positionChangedSinceLastRefine","boundingBoxChangedSinceLastRefine","hits","filter","hit","_geoloc","getConfiguration","previous","configuration","aroundLatLngViaIP","aroundRadius","aroundPrecision","dispose","_ref2","nextState"],"mappings":"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","sourcesContent":["import noop from 'lodash/noop';\nimport { checkRendering, parseAroundLatLngFromString } from '../../lib/utils';\n\nvar usage = 'Usage:\\n\\nvar customGeoSearch = connectGeoSearch(function render(params, isFirstRendering) {\\n  // params = {\\n  //   items,\\n  //   position,\\n  //   refine,\\n  //   clearMapRefinement,\\n  //   isRefinedWithMap,\\n  //   toggleRefineOnMapMove,\\n  //   isRefineOnMapMove,\\n  //   setMapMoveSinceLastRefine,\\n  //   hasMapMoveSinceLastRefine,\\n  //   hasMapMoveSinceLastRefine,\\n  //   widgetParams,\\n  //   instantSearchInstance,\\n  // }\\n});\\n\\nsearch.addWidget(\\n  customGeoSearch({\\n    [ enableRefineOnMapMove = true ],\\n    [ enableGeolocationWithIP = true ],\\n    [ position ],\\n    [ radius ],\\n    [ precision ],\\n    [ transformItems ],\\n  })\\n);\\n\\nFull documentation available at https://community.algolia.com/instantsearch.js/v2/connectors/connectGeoSearch.html\\n';\n\n/**\n * @typedef {Object} LatLng\n * @property {number} lat The latitude in degrees.\n * @property {number} lng The longitude in degrees.\n */\n\n/**\n * @typedef {Object} Bounds\n * @property {LatLng} northEast The top right corner of the map view.\n * @property {LatLng} southWest The bottom left corner of the map view.\n */\n\n/**\n * @typedef {Object} CustomGeoSearchWidgetOptions\n * @property {boolean} [enableRefineOnMapMove=true] If true, refine will be triggered as you move the map.\n * @property {boolean} [enableGeolocationWithIP=true] If true, the IP will be use for the geolocation. When the `position` option is provided this option will be ignored. See [the documentation](https://www.algolia.com/doc/api-reference/api-parameters/aroundLatLngViaIP) for more information.\n * @property {LatLng} [position] Position that will be use to search around. <br />\n * See [the documentation](https://www.algolia.com/doc/api-reference/api-parameters/aroundLatLng) for more information.\n * @property {number} [radius] Maximum radius to search around the position (in meters). <br />\n * See [the documentation](https://www.algolia.com/doc/api-reference/api-parameters/aroundRadius) for more information.\n * @property {number} [precision] Precision of geo search (in meters). <br />\n * See [the documentation](https://www.algolia.com/doc/api-reference/api-parameters/aroundPrecision) for more information.\n * @property {function(object[]):object[]} [transformItems] Function to transform the items passed to the templates.\n */\n\n/**\n * @typedef {Object} GeoSearchRenderingOptions\n * @property {Object[]} items The matched hits from Algolia API.\n * @property {function(Bounds)} refine Sets a bounding box to filter the results from the given map bounds.\n * @property {function()} clearMapRefinement Reset the current bounding box refinement.\n * @property {function(): boolean} isRefinedWithMap Return true if the current refinement is set with the map bounds.\n * @property {function()} toggleRefineOnMapMove Toggle the fact that the user is able to refine on map move.\n * @property {function(): boolean} isRefineOnMapMove Return true if the user is able to refine on map move.\n * @property {function()} setMapMoveSinceLastRefine Set the fact that the map has moved since the last refinement, should be call on each map move. The call to the function triggers a new rendering only when the value change.\n * @property {function(): boolean} hasMapMoveSinceLastRefine Return true if the map has move since the last refinement.\n * @property {Object} widgetParams All original `CustomGeoSearchWidgetOptions` forwarded to the `renderFn`.\n * @property {LatLng} [position] The current position of the search.\n */\n\n/**\n * The **GeoSearch** connector provides the logic to build a widget that will display the results on a map. It also provides a way to search for results based on their position. The connector provides functions to manage the search experience (search on map interaction or control the interaction for example).\n *\n * @requirements\n *\n * Note that the GeoSearch connector uses the [geosearch](https://www.algolia.com/doc/guides/searching/geo-search) capabilities of Algolia. Your hits **must** have a `_geoloc` attribute in order to be passed to the rendering function.\n *\n * Currently, the feature is not compatible with multiple values in the _geoloc attribute.\n *\n * @type {Connector}\n * @canonical https://www.algolia.com/doc/api-reference/widgets/geo-search/js/\n * @param {function(GeoSearchRenderingOptions, boolean)} renderFn Rendering function for the custom **GeoSearch** widget.\n * @param {function} unmountFn Unmount function called when the widget is disposed.\n * @return {function(CustomGeoSearchWidgetOptions)} Re-usable widget factory for a custom **GeoSearch** widget.\n * @staticExample\n * // This example use Leaflet for the rendering, be sure to have the library correctly setup\n * // before trying the demo. You can find more details in their documentation (link below).\n * // We choose Leaflet for the example but you can use any libraries that you want.\n * // See: http://leafletjs.com/examples/quick-start\n *\n * let map = null;\n * let markers = [];\n *\n * // custom `renderFn` to render the custom GeoSearch widget\n * function renderFn(GeoSearchRenderingOptions, isFirstRendering) {\n *   const { items, widgetParams } = GeoSearchRenderingOptions;\n *\n *   if (isFirstRendering) {\n *     map = L.map(widgetParams.container);\n *\n *     L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n *       attribution:\n *         '&copy; <a href=\"http://osm.org/copyright\">OpenStreetMap</a> contributors',\n *     }).addTo(map);\n *   }\n *\n *   markers.forEach(marker => marker.remove());\n *\n *   markers = items.map(({ _geoloc }) =>\n *     L.marker([_geoloc.lat, _geoloc.lng]).addTo(map)\n *   );\n *\n *   if (markers.length) {\n *     map.fitBounds(L.featureGroup(markers).getBounds());\n *   }\n * }\n *\n * // connect `renderFn` to GeoSearch logic\n * const customGeoSearch = instantsearch.connectors.connectGeoSearch(renderFn);\n *\n * // mount widget on the page\n * search.addWidget(\n *   customGeoSearch({\n *     container: document.getElementById('custom-geo-search'),\n *   })\n * );\n */\nvar connectGeoSearch = function connectGeoSearch(renderFn, unmountFn) {\n  checkRendering(renderFn, usage);\n\n  return function () {\n    var widgetParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var _widgetParams$enableR = widgetParams.enableRefineOnMapMove,\n        enableRefineOnMapMove = _widgetParams$enableR === undefined ? true : _widgetParams$enableR,\n        _widgetParams$enableG = widgetParams.enableGeolocationWithIP,\n        enableGeolocationWithIP = _widgetParams$enableG === undefined ? true : _widgetParams$enableG,\n        position = widgetParams.position,\n        radius = widgetParams.radius,\n        precision = widgetParams.precision,\n        _widgetParams$transfo = widgetParams.transformItems,\n        transformItems = _widgetParams$transfo === undefined ? function (items) {\n      return items;\n    } : _widgetParams$transfo;\n\n\n    var widgetState = {\n      isRefineOnMapMove: enableRefineOnMapMove,\n      hasMapMoveSinceLastRefine: false,\n      lastRefinePosition: '',\n      lastRefineBoundingBox: '',\n      internalToggleRefineOnMapMove: noop,\n      internalSetMapMoveSinceLastRefine: noop\n    };\n\n    var getPositionFromState = function getPositionFromState(state) {\n      return state.aroundLatLng && parseAroundLatLngFromString(state.aroundLatLng);\n    };\n\n    var refine = function refine(helper) {\n      return function (_ref) {\n        var ne = _ref.northEast,\n            sw = _ref.southWest;\n\n        var boundingBox = [ne.lat, ne.lng, sw.lat, sw.lng].join();\n\n        helper.setQueryParameter('insideBoundingBox', boundingBox).search();\n\n        widgetState.hasMapMoveSinceLastRefine = false;\n        widgetState.lastRefineBoundingBox = boundingBox;\n      };\n    };\n\n    var clearMapRefinement = function clearMapRefinement(helper) {\n      return function () {\n        helper.setQueryParameter('insideBoundingBox').search();\n      };\n    };\n\n    var isRefinedWithMap = function isRefinedWithMap(state) {\n      return function () {\n        return Boolean(state.insideBoundingBox);\n      };\n    };\n\n    var toggleRefineOnMapMove = function toggleRefineOnMapMove() {\n      return widgetState.internalToggleRefineOnMapMove();\n    };\n    var createInternalToggleRefinementonMapMove = function createInternalToggleRefinementonMapMove(render, args) {\n      return function () {\n        widgetState.isRefineOnMapMove = !widgetState.isRefineOnMapMove;\n\n        render(args);\n      };\n    };\n\n    var isRefineOnMapMove = function isRefineOnMapMove() {\n      return widgetState.isRefineOnMapMove;\n    };\n\n    var setMapMoveSinceLastRefine = function setMapMoveSinceLastRefine() {\n      return widgetState.internalSetMapMoveSinceLastRefine();\n    };\n    var createInternalSetMapMoveSinceLastRefine = function createInternalSetMapMoveSinceLastRefine(render, args) {\n      return function () {\n        var shouldTriggerRender = widgetState.hasMapMoveSinceLastRefine !== true;\n\n        widgetState.hasMapMoveSinceLastRefine = true;\n\n        if (shouldTriggerRender) {\n          render(args);\n        }\n      };\n    };\n\n    var hasMapMoveSinceLastRefine = function hasMapMoveSinceLastRefine() {\n      return widgetState.hasMapMoveSinceLastRefine;\n    };\n\n    var init = function init(initArgs) {\n      var state = initArgs.state,\n          helper = initArgs.helper,\n          instantSearchInstance = initArgs.instantSearchInstance;\n\n      var isFirstRendering = true;\n\n      widgetState.internalToggleRefineOnMapMove = createInternalToggleRefinementonMapMove(noop, initArgs);\n\n      widgetState.internalSetMapMoveSinceLastRefine = createInternalSetMapMoveSinceLastRefine(noop, initArgs);\n\n      renderFn({\n        items: [],\n        position: getPositionFromState(state),\n        refine: refine(helper),\n        clearMapRefinement: clearMapRefinement(helper),\n        isRefinedWithMap: isRefinedWithMap(state),\n        toggleRefineOnMapMove: toggleRefineOnMapMove,\n        isRefineOnMapMove: isRefineOnMapMove,\n        setMapMoveSinceLastRefine: setMapMoveSinceLastRefine,\n        hasMapMoveSinceLastRefine: hasMapMoveSinceLastRefine,\n        widgetParams: widgetParams,\n        instantSearchInstance: instantSearchInstance\n      }, isFirstRendering);\n    };\n\n    var render = function render(renderArgs) {\n      var results = renderArgs.results,\n          helper = renderArgs.helper,\n          instantSearchInstance = renderArgs.instantSearchInstance;\n\n      var isFirstRendering = false;\n      // We don't use the state provided by the render function because we need\n      // to be sure that the state is the latest one for the following condition\n      var state = helper.getState();\n\n      var positionChangedSinceLastRefine = Boolean(state.aroundLatLng) && Boolean(widgetState.lastRefinePosition) && state.aroundLatLng !== widgetState.lastRefinePosition;\n\n      var boundingBoxChangedSinceLastRefine = !state.insideBoundingBox && Boolean(widgetState.lastRefineBoundingBox) && state.insideBoundingBox !== widgetState.lastRefineBoundingBox;\n\n      if (positionChangedSinceLastRefine || boundingBoxChangedSinceLastRefine) {\n        widgetState.hasMapMoveSinceLastRefine = false;\n      }\n\n      widgetState.lastRefinePosition = state.aroundLatLng || '';\n      widgetState.lastRefineBoundingBox = state.insideBoundingBox || '';\n\n      widgetState.internalToggleRefineOnMapMove = createInternalToggleRefinementonMapMove(render, renderArgs);\n\n      widgetState.internalSetMapMoveSinceLastRefine = createInternalSetMapMoveSinceLastRefine(render, renderArgs);\n\n      var items = transformItems(results.hits.filter(function (hit) {\n        return hit._geoloc;\n      }));\n\n      renderFn({\n        items: items,\n        position: getPositionFromState(state),\n        refine: refine(helper),\n        clearMapRefinement: clearMapRefinement(helper),\n        isRefinedWithMap: isRefinedWithMap(state),\n        toggleRefineOnMapMove: toggleRefineOnMapMove,\n        isRefineOnMapMove: isRefineOnMapMove,\n        setMapMoveSinceLastRefine: setMapMoveSinceLastRefine,\n        hasMapMoveSinceLastRefine: hasMapMoveSinceLastRefine,\n        widgetParams: widgetParams,\n        instantSearchInstance: instantSearchInstance\n      }, isFirstRendering);\n    };\n\n    return {\n      init: init,\n      render: render,\n\n      getConfiguration: function getConfiguration(previous) {\n        var configuration = {};\n\n        if (enableGeolocationWithIP && !position && !previous.aroundLatLng && previous.aroundLatLngViaIP === undefined) {\n          configuration.aroundLatLngViaIP = true;\n        }\n\n        if (position && !previous.aroundLatLng && !previous.aroundLatLngViaIP) {\n          configuration.aroundLatLng = position.lat + ', ' + position.lng;\n        }\n\n        if (radius && !previous.aroundRadius) {\n          configuration.aroundRadius = radius;\n        }\n\n        if (precision && !previous.aroundPrecision) {\n          configuration.aroundPrecision = precision;\n        }\n\n        return configuration;\n      },\n      dispose: function dispose(_ref2) {\n        var state = _ref2.state;\n\n        unmountFn();\n\n        var nextState = state;\n\n        if (enableGeolocationWithIP && !position) {\n          nextState = nextState.setQueryParameter('aroundLatLngViaIP');\n        }\n\n        if (position) {\n          nextState = nextState.setQueryParameter('aroundLatLng');\n        }\n\n        if (radius) {\n          nextState = nextState.setQueryParameter('aroundRadius');\n        }\n\n        if (precision) {\n          nextState = nextState.setQueryParameter('aroundPrecision');\n        }\n\n        nextState = nextState.setQueryParameter('insideBoundingBox');\n\n        return nextState;\n      }\n    };\n  };\n};\n\nexport default connectGeoSearch;"]},"metadata":{},"sourceType":"module"}