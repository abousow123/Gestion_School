{"ast":null,"code":"var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nimport reduce from 'lodash/reduce';\nimport forEach from 'lodash/forEach';\nimport find from 'lodash/find';\nimport get from 'lodash/get';\nimport keys from 'lodash/keys';\nimport uniq from 'lodash/uniq';\nimport mapKeys from 'lodash/mapKeys';\nimport mapValues from 'lodash/mapValues';\nimport curry from 'lodash/curry';\nimport hogan from 'hogan.js';\nexport { getContainerNode, bemHelper, prepareTemplateProps, renderTemplate, isSpecialClick, isDomElement, getRefinements, getAttributesToClear, clearRefinements, prefixKeys, escapeRefinement, unescapeRefinement, checkRendering, isReactElement, deprecate, warn, parseAroundLatLngFromString };\n/**\n * Return the container. If it's a string, it is considered a\n * css selector and retrieves the first matching element. Otherwise\n * test if it validates that it's a correct DOMElement.\n * @param {string|HTMLElement} selectorOrHTMLElement a selector or a node\n * @return {HTMLElement} The resolved HTMLElement\n * @throws Error when the type is not correct\n */\n\nfunction getContainerNode(selectorOrHTMLElement) {\n  var isFromString = typeof selectorOrHTMLElement === 'string';\n  var domElement = void 0;\n\n  if (isFromString) {\n    domElement = document.querySelector(selectorOrHTMLElement);\n  } else {\n    domElement = selectorOrHTMLElement;\n  }\n\n  if (!isDomElement(domElement)) {\n    var errorMessage = 'Container must be `string` or `HTMLElement`.';\n\n    if (isFromString) {\n      errorMessage += ' Unable to find ' + selectorOrHTMLElement;\n    }\n\n    throw new Error(errorMessage);\n  }\n\n  return domElement;\n}\n/**\n * Returns true if the parameter is a DOMElement.\n * @param {any} o the value to test\n * @return {boolean} true if o is a DOMElement\n */\n\n\nfunction isDomElement(o) {\n  return o instanceof window.HTMLElement || Boolean(o) && o.nodeType > 0;\n}\n\nfunction isSpecialClick(event) {\n  var isMiddleClick = event.button === 1;\n  return isMiddleClick || event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;\n}\n/**\n * Creates BEM class name according the vanilla BEM style.\n * @param {string} block the main block\n * @return {function} function that takes up to 2 parameters\n * that determine the element and the modifier of the BEM class.\n */\n\n\nfunction bemHelper(block) {\n  return function (element, modifier) {\n    // block--element\n    if (element && !modifier) {\n      return block + '--' + element;\n    } // block--element__modifier\n\n\n    if (element && modifier) {\n      return block + '--' + element + '__' + modifier;\n    } // block__modifier\n\n\n    if (!element && modifier) {\n      return block + '__' + modifier;\n    }\n\n    return block;\n  };\n}\n/**\n * Prepares an object to be passed to the Template widget\n * @param {object} unknownBecauseES6 an object with the following attributes:\n *  - transformData\n *  - defaultTemplate\n *  - templates\n *  - templatesConfig\n * @return {object} the configuration with the attributes:\n *  - transformData\n *  - defaultTemplate\n *  - templates\n *  - useCustomCompileOptions\n */\n\n\nfunction prepareTemplateProps(_ref) {\n  var transformData = _ref.transformData,\n      defaultTemplates = _ref.defaultTemplates,\n      templates = _ref.templates,\n      templatesConfig = _ref.templatesConfig;\n  var preparedTemplates = prepareTemplates(defaultTemplates, templates);\n  return _extends({\n    transformData: transformData,\n    templatesConfig: templatesConfig\n  }, preparedTemplates);\n}\n\nfunction prepareTemplates() {\n  var defaultTemplates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var templates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var allKeys = uniq([].concat(_toConsumableArray(keys(defaultTemplates)), _toConsumableArray(keys(templates))));\n  return reduce(allKeys, function (config, key) {\n    var defaultTemplate = defaultTemplates[key];\n    var customTemplate = templates[key];\n    var isCustomTemplate = customTemplate !== undefined && customTemplate !== defaultTemplate;\n    config.templates[key] = isCustomTemplate ? customTemplate : defaultTemplate;\n    config.useCustomCompileOptions[key] = isCustomTemplate;\n    return config;\n  }, {\n    templates: {},\n    useCustomCompileOptions: {}\n  });\n}\n\nfunction renderTemplate(_ref2) {\n  var templates = _ref2.templates,\n      templateKey = _ref2.templateKey,\n      compileOptions = _ref2.compileOptions,\n      helpers = _ref2.helpers,\n      data = _ref2.data;\n  var template = templates[templateKey];\n  var templateType = typeof template === 'undefined' ? 'undefined' : _typeof(template);\n  var isTemplateString = templateType === 'string';\n  var isTemplateFunction = templateType === 'function';\n\n  if (!isTemplateString && !isTemplateFunction) {\n    throw new Error('Template must be \\'string\\' or \\'function\\', was \\'' + templateType + '\\' (key: ' + templateKey + ')');\n  }\n\n  if (isTemplateFunction) {\n    return template(data);\n  }\n\n  var transformedHelpers = transformHelpersToHogan(helpers, compileOptions, data);\n  return hogan.compile(template, compileOptions).render(_extends({}, data, {\n    helpers: transformedHelpers\n  }));\n} // We add all our template helper methods to the template as lambdas. Note\n// that lambdas in Mustache are supposed to accept a second argument of\n// `render` to get the rendered value, not the literal `{{value}}`. But\n// this is currently broken (see https://github.com/twitter/hogan.js/issues/222).\n\n\nfunction transformHelpersToHogan(helpers, compileOptions, data) {\n  return mapValues(helpers, function (method) {\n    return curry(function (text) {\n      var _this = this;\n\n      var render = function render(value) {\n        return hogan.compile(value, compileOptions).render(_this);\n      };\n\n      return method.call(data, text, render);\n    });\n  });\n}\n\nfunction getRefinement(state, type, attributeName, name, resultsFacets) {\n  var res = {\n    type: type,\n    attributeName: attributeName,\n    name: name\n  };\n  var facet = find(resultsFacets, {\n    name: attributeName\n  });\n  var count = void 0;\n\n  if (type === 'hierarchical') {\n    var facetDeclaration = state.getHierarchicalFacetByName(attributeName);\n    var split = name.split(facetDeclaration.separator);\n    res.name = split[split.length - 1];\n\n    for (var i = 0; facet !== undefined && i < split.length; ++i) {\n      facet = find(facet.data, {\n        name: split[i]\n      });\n    }\n\n    count = get(facet, 'count');\n  } else {\n    count = get(facet, 'data[\"' + res.name + '\"]');\n  }\n\n  var exhaustive = get(facet, 'exhaustive');\n\n  if (count !== undefined) {\n    res.count = count;\n  }\n\n  if (exhaustive !== undefined) {\n    res.exhaustive = exhaustive;\n  }\n\n  return res;\n}\n\nfunction getRefinements(results, state, clearsQuery) {\n  var res = clearsQuery && state.query && state.query.trim() ? [{\n    type: 'query',\n    name: state.query,\n    query: state.query,\n    attributeName: 'query'\n  }] : [];\n  forEach(state.facetsRefinements, function (refinements, attributeName) {\n    forEach(refinements, function (name) {\n      res.push(getRefinement(state, 'facet', attributeName, name, results.facets));\n    });\n  });\n  forEach(state.facetsExcludes, function (refinements, attributeName) {\n    forEach(refinements, function (name) {\n      res.push({\n        type: 'exclude',\n        attributeName: attributeName,\n        name: name,\n        exclude: true\n      });\n    });\n  });\n  forEach(state.disjunctiveFacetsRefinements, function (refinements, attributeName) {\n    forEach(refinements, function (name) {\n      res.push(getRefinement(state, 'disjunctive', attributeName, // we unescapeRefinement any disjunctive refined value since they can be escaped\n      // when negative numeric values search `escapeRefinement` usage in code\n      unescapeRefinement(name), results.disjunctiveFacets));\n    });\n  });\n  forEach(state.hierarchicalFacetsRefinements, function (refinements, attributeName) {\n    forEach(refinements, function (name) {\n      res.push(getRefinement(state, 'hierarchical', attributeName, name, results.hierarchicalFacets));\n    });\n  });\n  forEach(state.numericRefinements, function (operators, attributeName) {\n    forEach(operators, function (values, operator) {\n      forEach(values, function (value) {\n        res.push({\n          type: 'numeric',\n          attributeName: attributeName,\n          name: '' + value,\n          numericValue: value,\n          operator: operator\n        });\n      });\n    });\n  });\n  forEach(state.tagRefinements, function (name) {\n    res.push({\n      type: 'tag',\n      attributeName: '_tags',\n      name: name\n    });\n  });\n  return res;\n}\n/**\n * Clears the refinements of a SearchParameters object based on rules provided.\n * The white list is first used then the black list is applied. If no white list\n * is provided, all the current refinements are used.\n * @param {object} $0 parameters\n * @param {Helper} $0.helper instance of the Helper\n * @param {string[]} [$0.whiteList] list of parameters to clear\n * @param {string[]} [$0.blackList=[]] list of parameters not to remove (will impact the white list)\n * @param {boolean} [$0.clearsQuery=false] clears the query if need be\n * @returns {SearchParameters} search parameters with refinements cleared\n */\n\n\nfunction clearRefinements(_ref3) {\n  var helper = _ref3.helper,\n      whiteList = _ref3.whiteList,\n      _ref3$blackList = _ref3.blackList,\n      blackList = _ref3$blackList === undefined ? [] : _ref3$blackList,\n      _ref3$clearsQuery = _ref3.clearsQuery,\n      clearsQuery = _ref3$clearsQuery === undefined ? false : _ref3$clearsQuery;\n  var attributesToClear = getAttributesToClear({\n    helper: helper,\n    whiteList: whiteList,\n    blackList: blackList\n  });\n  var finalState = helper.state;\n  attributesToClear.forEach(function (attribute) {\n    if (attribute === '_tags') {\n      finalState = finalState.clearTags();\n    } else {\n      finalState = finalState.clearRefinements(attribute);\n    }\n  });\n\n  if (clearsQuery) {\n    finalState = finalState.setQuery('');\n  }\n\n  return finalState;\n}\n/**\n * Computes the list of attributes (conjunctive, disjunctive, hierarchical facet + numerical attributes)\n * to clear based on a optional white and black lists. The white list is applied first then the black list.\n * @param {object} $0 parameters\n * @param {Helper} $0.helper instance of the Helper\n * @param {string[]} [$0.whiteList] attributes to clear (defaults to all attributes)\n * @param {string[]} [$0.blackList=[]] attributes to keep, will override the white list\n * @returns {string[]} the list of attributes to clear based on the rules\n */\n\n\nfunction getAttributesToClear(_ref4) {\n  var helper = _ref4.helper,\n      whiteList = _ref4.whiteList,\n      blackList = _ref4.blackList;\n  var lastResults = helper.lastResults || {};\n  var attributesToClear = whiteList || getRefinements(lastResults, helper.state).map(function (one) {\n    return one.attributeName;\n  });\n  return attributesToClear.filter(function (attribute) {\n    return blackList.indexOf(attribute) === -1;\n  });\n}\n\nfunction prefixKeys(prefix, obj) {\n  if (obj) {\n    return mapKeys(obj, function (v, k) {\n      return prefix + k;\n    });\n  }\n\n  return undefined;\n}\n\nfunction escapeRefinement(value) {\n  if (typeof value === 'number' && value < 0) {\n    value = String(value).replace(/^-/, '\\\\-');\n  }\n\n  return value;\n}\n\nfunction unescapeRefinement(value) {\n  return String(value).replace(/^\\\\-/, '-');\n}\n\nfunction checkRendering(rendering, usage) {\n  if (rendering === undefined || typeof rendering !== 'function') {\n    throw new Error(usage);\n  }\n}\n\nvar REACT_ELEMENT_TYPE = typeof Symbol === 'function' && _typeof(Symbol.iterator) === 'symbol' && Symbol.for && Symbol.for('react.element') || 0xeac7;\n\nfunction isReactElement(object) {\n  return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\n\nfunction logger(message) {\n  // eslint-disable-next-line no-console\n  console.warn('[InstantSearch.js]: ' + message.trim());\n}\n\nfunction deprecate(fn, message) {\n  var hasAlreadyPrint = false;\n  return function () {\n    if (!hasAlreadyPrint) {\n      hasAlreadyPrint = true;\n      logger(message);\n    }\n\n    return fn.apply(undefined, arguments);\n  };\n}\n\nwarn.cache = {};\n\nfunction warn(message) {\n  var hasAlreadyPrint = warn.cache[message];\n\n  if (!hasAlreadyPrint) {\n    warn.cache[message] = true;\n    logger(message);\n  }\n}\n\nvar latLngRegExp = /^(-?\\d+(?:\\.\\d+)?),\\s*(-?\\d+(?:\\.\\d+)?)$/;\n\nfunction parseAroundLatLngFromString(value) {\n  var pattern = value.match(latLngRegExp); // Since the value provided is the one send with the query, the API should\n  // throw an error due to the wrong format. So throw an error should be safe..\n\n  if (!pattern) {\n    throw new Error('Invalid value for \"aroundLatLng\" parameter: \"' + value + '\"');\n  }\n\n  return {\n    lat: parseFloat(pattern[1]),\n    lng: parseFloat(pattern[2])\n  };\n}","map":{"version":3,"sources":["/home/sow/Bureau/ProjetPerso/Gestion_School/embryo-angular/node_modules/instantsearch.js/es/lib/utils.js"],"names":["_typeof","Symbol","iterator","obj","constructor","prototype","_extends","Object","assign","target","i","arguments","length","source","key","hasOwnProperty","call","_toConsumableArray","arr","Array","isArray","arr2","from","reduce","forEach","find","get","keys","uniq","mapKeys","mapValues","curry","hogan","getContainerNode","bemHelper","prepareTemplateProps","renderTemplate","isSpecialClick","isDomElement","getRefinements","getAttributesToClear","clearRefinements","prefixKeys","escapeRefinement","unescapeRefinement","checkRendering","isReactElement","deprecate","warn","parseAroundLatLngFromString","selectorOrHTMLElement","isFromString","domElement","document","querySelector","errorMessage","Error","o","window","HTMLElement","Boolean","nodeType","event","isMiddleClick","button","altKey","ctrlKey","metaKey","shiftKey","block","element","modifier","_ref","transformData","defaultTemplates","templates","templatesConfig","preparedTemplates","prepareTemplates","undefined","allKeys","concat","config","defaultTemplate","customTemplate","isCustomTemplate","useCustomCompileOptions","_ref2","templateKey","compileOptions","helpers","data","template","templateType","isTemplateString","isTemplateFunction","transformedHelpers","transformHelpersToHogan","compile","render","method","text","_this","value","getRefinement","state","type","attributeName","name","resultsFacets","res","facet","count","facetDeclaration","getHierarchicalFacetByName","split","separator","exhaustive","results","clearsQuery","query","trim","facetsRefinements","refinements","push","facets","facetsExcludes","exclude","disjunctiveFacetsRefinements","disjunctiveFacets","hierarchicalFacetsRefinements","hierarchicalFacets","numericRefinements","operators","values","operator","numericValue","tagRefinements","_ref3","helper","whiteList","_ref3$blackList","blackList","_ref3$clearsQuery","attributesToClear","finalState","attribute","clearTags","setQuery","_ref4","lastResults","map","one","filter","indexOf","prefix","v","k","String","replace","rendering","usage","REACT_ELEMENT_TYPE","for","object","$$typeof","logger","message","console","fn","hasAlreadyPrint","apply","cache","latLngRegExp","pattern","match","lat","parseFloat","lng"],"mappings":"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","sourcesContent":["var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\nimport reduce from 'lodash/reduce';\nimport forEach from 'lodash/forEach';\nimport find from 'lodash/find';\nimport get from 'lodash/get';\nimport keys from 'lodash/keys';\nimport uniq from 'lodash/uniq';\nimport mapKeys from 'lodash/mapKeys';\nimport mapValues from 'lodash/mapValues';\nimport curry from 'lodash/curry';\nimport hogan from 'hogan.js';\n\nexport { getContainerNode, bemHelper, prepareTemplateProps, renderTemplate, isSpecialClick, isDomElement, getRefinements, getAttributesToClear, clearRefinements, prefixKeys, escapeRefinement, unescapeRefinement, checkRendering, isReactElement, deprecate, warn, parseAroundLatLngFromString };\n\n/**\n * Return the container. If it's a string, it is considered a\n * css selector and retrieves the first matching element. Otherwise\n * test if it validates that it's a correct DOMElement.\n * @param {string|HTMLElement} selectorOrHTMLElement a selector or a node\n * @return {HTMLElement} The resolved HTMLElement\n * @throws Error when the type is not correct\n */\nfunction getContainerNode(selectorOrHTMLElement) {\n  var isFromString = typeof selectorOrHTMLElement === 'string';\n  var domElement = void 0;\n  if (isFromString) {\n    domElement = document.querySelector(selectorOrHTMLElement);\n  } else {\n    domElement = selectorOrHTMLElement;\n  }\n\n  if (!isDomElement(domElement)) {\n    var errorMessage = 'Container must be `string` or `HTMLElement`.';\n    if (isFromString) {\n      errorMessage += ' Unable to find ' + selectorOrHTMLElement;\n    }\n    throw new Error(errorMessage);\n  }\n\n  return domElement;\n}\n\n/**\n * Returns true if the parameter is a DOMElement.\n * @param {any} o the value to test\n * @return {boolean} true if o is a DOMElement\n */\nfunction isDomElement(o) {\n  return o instanceof window.HTMLElement || Boolean(o) && o.nodeType > 0;\n}\n\nfunction isSpecialClick(event) {\n  var isMiddleClick = event.button === 1;\n  return isMiddleClick || event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;\n}\n\n/**\n * Creates BEM class name according the vanilla BEM style.\n * @param {string} block the main block\n * @return {function} function that takes up to 2 parameters\n * that determine the element and the modifier of the BEM class.\n */\nfunction bemHelper(block) {\n  return function (element, modifier) {\n    // block--element\n    if (element && !modifier) {\n      return block + '--' + element;\n    }\n    // block--element__modifier\n    if (element && modifier) {\n      return block + '--' + element + '__' + modifier;\n    }\n    // block__modifier\n    if (!element && modifier) {\n      return block + '__' + modifier;\n    }\n\n    return block;\n  };\n}\n\n/**\n * Prepares an object to be passed to the Template widget\n * @param {object} unknownBecauseES6 an object with the following attributes:\n *  - transformData\n *  - defaultTemplate\n *  - templates\n *  - templatesConfig\n * @return {object} the configuration with the attributes:\n *  - transformData\n *  - defaultTemplate\n *  - templates\n *  - useCustomCompileOptions\n */\nfunction prepareTemplateProps(_ref) {\n  var transformData = _ref.transformData,\n      defaultTemplates = _ref.defaultTemplates,\n      templates = _ref.templates,\n      templatesConfig = _ref.templatesConfig;\n\n  var preparedTemplates = prepareTemplates(defaultTemplates, templates);\n\n  return _extends({\n    transformData: transformData,\n    templatesConfig: templatesConfig\n  }, preparedTemplates);\n}\n\nfunction prepareTemplates() {\n  var defaultTemplates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var templates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var allKeys = uniq([].concat(_toConsumableArray(keys(defaultTemplates)), _toConsumableArray(keys(templates))));\n\n  return reduce(allKeys, function (config, key) {\n    var defaultTemplate = defaultTemplates[key];\n    var customTemplate = templates[key];\n    var isCustomTemplate = customTemplate !== undefined && customTemplate !== defaultTemplate;\n\n    config.templates[key] = isCustomTemplate ? customTemplate : defaultTemplate;\n    config.useCustomCompileOptions[key] = isCustomTemplate;\n\n    return config;\n  }, { templates: {}, useCustomCompileOptions: {} });\n}\n\nfunction renderTemplate(_ref2) {\n  var templates = _ref2.templates,\n      templateKey = _ref2.templateKey,\n      compileOptions = _ref2.compileOptions,\n      helpers = _ref2.helpers,\n      data = _ref2.data;\n\n  var template = templates[templateKey];\n  var templateType = typeof template === 'undefined' ? 'undefined' : _typeof(template);\n  var isTemplateString = templateType === 'string';\n  var isTemplateFunction = templateType === 'function';\n\n  if (!isTemplateString && !isTemplateFunction) {\n    throw new Error('Template must be \\'string\\' or \\'function\\', was \\'' + templateType + '\\' (key: ' + templateKey + ')');\n  }\n\n  if (isTemplateFunction) {\n    return template(data);\n  }\n\n  var transformedHelpers = transformHelpersToHogan(helpers, compileOptions, data);\n\n  return hogan.compile(template, compileOptions).render(_extends({}, data, {\n    helpers: transformedHelpers\n  }));\n}\n\n// We add all our template helper methods to the template as lambdas. Note\n// that lambdas in Mustache are supposed to accept a second argument of\n// `render` to get the rendered value, not the literal `{{value}}`. But\n// this is currently broken (see https://github.com/twitter/hogan.js/issues/222).\nfunction transformHelpersToHogan(helpers, compileOptions, data) {\n  return mapValues(helpers, function (method) {\n    return curry(function (text) {\n      var _this = this;\n\n      var render = function render(value) {\n        return hogan.compile(value, compileOptions).render(_this);\n      };\n      return method.call(data, text, render);\n    });\n  });\n}\n\nfunction getRefinement(state, type, attributeName, name, resultsFacets) {\n  var res = { type: type, attributeName: attributeName, name: name };\n  var facet = find(resultsFacets, { name: attributeName });\n  var count = void 0;\n  if (type === 'hierarchical') {\n    var facetDeclaration = state.getHierarchicalFacetByName(attributeName);\n    var split = name.split(facetDeclaration.separator);\n    res.name = split[split.length - 1];\n    for (var i = 0; facet !== undefined && i < split.length; ++i) {\n      facet = find(facet.data, { name: split[i] });\n    }\n    count = get(facet, 'count');\n  } else {\n    count = get(facet, 'data[\"' + res.name + '\"]');\n  }\n  var exhaustive = get(facet, 'exhaustive');\n  if (count !== undefined) {\n    res.count = count;\n  }\n  if (exhaustive !== undefined) {\n    res.exhaustive = exhaustive;\n  }\n  return res;\n}\n\nfunction getRefinements(results, state, clearsQuery) {\n  var res = clearsQuery && state.query && state.query.trim() ? [{\n    type: 'query',\n    name: state.query,\n    query: state.query,\n    attributeName: 'query'\n  }] : [];\n\n  forEach(state.facetsRefinements, function (refinements, attributeName) {\n    forEach(refinements, function (name) {\n      res.push(getRefinement(state, 'facet', attributeName, name, results.facets));\n    });\n  });\n\n  forEach(state.facetsExcludes, function (refinements, attributeName) {\n    forEach(refinements, function (name) {\n      res.push({ type: 'exclude', attributeName: attributeName, name: name, exclude: true });\n    });\n  });\n\n  forEach(state.disjunctiveFacetsRefinements, function (refinements, attributeName) {\n    forEach(refinements, function (name) {\n      res.push(getRefinement(state, 'disjunctive', attributeName,\n      // we unescapeRefinement any disjunctive refined value since they can be escaped\n      // when negative numeric values search `escapeRefinement` usage in code\n      unescapeRefinement(name), results.disjunctiveFacets));\n    });\n  });\n\n  forEach(state.hierarchicalFacetsRefinements, function (refinements, attributeName) {\n    forEach(refinements, function (name) {\n      res.push(getRefinement(state, 'hierarchical', attributeName, name, results.hierarchicalFacets));\n    });\n  });\n\n  forEach(state.numericRefinements, function (operators, attributeName) {\n    forEach(operators, function (values, operator) {\n      forEach(values, function (value) {\n        res.push({\n          type: 'numeric',\n          attributeName: attributeName,\n          name: '' + value,\n          numericValue: value,\n          operator: operator\n        });\n      });\n    });\n  });\n\n  forEach(state.tagRefinements, function (name) {\n    res.push({ type: 'tag', attributeName: '_tags', name: name });\n  });\n\n  return res;\n}\n\n/**\n * Clears the refinements of a SearchParameters object based on rules provided.\n * The white list is first used then the black list is applied. If no white list\n * is provided, all the current refinements are used.\n * @param {object} $0 parameters\n * @param {Helper} $0.helper instance of the Helper\n * @param {string[]} [$0.whiteList] list of parameters to clear\n * @param {string[]} [$0.blackList=[]] list of parameters not to remove (will impact the white list)\n * @param {boolean} [$0.clearsQuery=false] clears the query if need be\n * @returns {SearchParameters} search parameters with refinements cleared\n */\nfunction clearRefinements(_ref3) {\n  var helper = _ref3.helper,\n      whiteList = _ref3.whiteList,\n      _ref3$blackList = _ref3.blackList,\n      blackList = _ref3$blackList === undefined ? [] : _ref3$blackList,\n      _ref3$clearsQuery = _ref3.clearsQuery,\n      clearsQuery = _ref3$clearsQuery === undefined ? false : _ref3$clearsQuery;\n\n  var attributesToClear = getAttributesToClear({\n    helper: helper,\n    whiteList: whiteList,\n    blackList: blackList\n  });\n\n  var finalState = helper.state;\n\n  attributesToClear.forEach(function (attribute) {\n    if (attribute === '_tags') {\n      finalState = finalState.clearTags();\n    } else {\n      finalState = finalState.clearRefinements(attribute);\n    }\n  });\n\n  if (clearsQuery) {\n    finalState = finalState.setQuery('');\n  }\n\n  return finalState;\n}\n\n/**\n * Computes the list of attributes (conjunctive, disjunctive, hierarchical facet + numerical attributes)\n * to clear based on a optional white and black lists. The white list is applied first then the black list.\n * @param {object} $0 parameters\n * @param {Helper} $0.helper instance of the Helper\n * @param {string[]} [$0.whiteList] attributes to clear (defaults to all attributes)\n * @param {string[]} [$0.blackList=[]] attributes to keep, will override the white list\n * @returns {string[]} the list of attributes to clear based on the rules\n */\nfunction getAttributesToClear(_ref4) {\n  var helper = _ref4.helper,\n      whiteList = _ref4.whiteList,\n      blackList = _ref4.blackList;\n\n  var lastResults = helper.lastResults || {};\n  var attributesToClear = whiteList || getRefinements(lastResults, helper.state).map(function (one) {\n    return one.attributeName;\n  });\n\n  return attributesToClear.filter(function (attribute) {\n    return blackList.indexOf(attribute) === -1;\n  });\n}\n\nfunction prefixKeys(prefix, obj) {\n  if (obj) {\n    return mapKeys(obj, function (v, k) {\n      return prefix + k;\n    });\n  }\n\n  return undefined;\n}\n\nfunction escapeRefinement(value) {\n  if (typeof value === 'number' && value < 0) {\n    value = String(value).replace(/^-/, '\\\\-');\n  }\n\n  return value;\n}\n\nfunction unescapeRefinement(value) {\n  return String(value).replace(/^\\\\-/, '-');\n}\n\nfunction checkRendering(rendering, usage) {\n  if (rendering === undefined || typeof rendering !== 'function') {\n    throw new Error(usage);\n  }\n}\n\nvar REACT_ELEMENT_TYPE = typeof Symbol === 'function' && _typeof(Symbol.iterator) === 'symbol' && Symbol.for && Symbol.for('react.element') || 0xeac7;\n\nfunction isReactElement(object) {\n  return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\n\nfunction logger(message) {\n  // eslint-disable-next-line no-console\n  console.warn('[InstantSearch.js]: ' + message.trim());\n}\n\nfunction deprecate(fn, message) {\n  var hasAlreadyPrint = false;\n\n  return function () {\n    if (!hasAlreadyPrint) {\n      hasAlreadyPrint = true;\n\n      logger(message);\n    }\n\n    return fn.apply(undefined, arguments);\n  };\n}\n\nwarn.cache = {};\nfunction warn(message) {\n  var hasAlreadyPrint = warn.cache[message];\n\n  if (!hasAlreadyPrint) {\n    warn.cache[message] = true;\n\n    logger(message);\n  }\n}\n\nvar latLngRegExp = /^(-?\\d+(?:\\.\\d+)?),\\s*(-?\\d+(?:\\.\\d+)?)$/;\nfunction parseAroundLatLngFromString(value) {\n  var pattern = value.match(latLngRegExp);\n\n  // Since the value provided is the one send with the query, the API should\n  // throw an error due to the wrong format. So throw an error should be safe..\n  if (!pattern) {\n    throw new Error('Invalid value for \"aroundLatLng\" parameter: \"' + value + '\"');\n  }\n\n  return {\n    lat: parseFloat(pattern[1]),\n    lng: parseFloat(pattern[2])\n  };\n}"]},"metadata":{},"sourceType":"module"}