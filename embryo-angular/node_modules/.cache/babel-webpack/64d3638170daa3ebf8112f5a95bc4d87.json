{"ast":null,"code":"var _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nimport qs from 'qs';\n\nfunction defaultCreateURL(_ref) {\n  var qsModule = _ref.qsModule,\n      routeState = _ref.routeState,\n      location = _ref.location;\n  var protocol = location.protocol,\n      hostname = location.hostname,\n      _location$port = location.port,\n      port = _location$port === undefined ? '' : _location$port,\n      pathname = location.pathname,\n      hash = location.hash;\n  var queryString = qsModule.stringify(routeState);\n  var portWithPrefix = port === '' ? '' : ':' + port; // IE <= 11 has no location.origin or buggy. Therefore we don't rely on it\n\n  if (!routeState || Object.keys(routeState).length === 0) return protocol + '//' + hostname + portWithPrefix + pathname + hash;else return protocol + '//' + hostname + portWithPrefix + pathname + '?' + queryString + hash;\n}\n\nfunction defaultParseURL(_ref2) {\n  var qsModule = _ref2.qsModule,\n      location = _ref2.location; // `qs` by default converts arrays with more than 20 items to an object.\n  // We want to avoid this because the data structure manipulated can therefore vary.\n  // Setting the limit to `100` seems a good number because the engine's default is 100\n  // (it can go up to 1000 but it is very unlikely to select more than 100 items in the UI).\n  //\n  // Using an `arrayLimit` of `n` allows `n + 1` items.\n  //\n  // See:\n  //   - https://github.com/ljharb/qs#parsing-arrays\n  //   - https://www.algolia.com/doc/api-reference/api-parameters/maxValuesPerFacet/\n\n  return qsModule.parse(location.search.slice(1), {\n    arrayLimit: 99\n  });\n}\n\nvar BrowserHistory = function () {\n  /**\n   * Initializes a new storage provider that will sync the search state in the URL\n   * using web API (window.location.pushState and onpopstate event).\n   * @param {object} $0 the options.\n   * @param {function(object):string} [$0.windowTitle] function that transforms a UI state\n   * into a title for the page. It takes one parameter: a syncable object (generated by the mapping\n   * provided to the URL sync). It should return a string that will be the title.\n   * @param {number} [$0.writeDelay = 400] time before a write is actually done.\n   * Prevent having too much entries in the history and thus make the back button more friendly.\n   * @param {function(qs, object):string} [$0.createURL] generates the full URL. If not provided,\n   * the storage adaptor will mapped all syncable keys to the query string of the URL. The first\n   * parameter is a utility object that has two methods: `stringify` that creates a query string\n   * from an object and `parse` that transforms a query string into an object.\n   * @param {function(qs): object} [$0.parseURL] parses an URL into an object. It should symetrical\n   * to `createURL`. It gets as an argument an object that contains two methods: `stringify` that\n   * creates a query string from an object and `parse` that transforms a query string into an object.\n   */\n  function BrowserHistory() {\n    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        windowTitle = _ref3.windowTitle,\n        _ref3$writeDelay = _ref3.writeDelay,\n        writeDelay = _ref3$writeDelay === undefined ? 400 : _ref3$writeDelay,\n        _ref3$createURL = _ref3.createURL,\n        createURL = _ref3$createURL === undefined ? defaultCreateURL : _ref3$createURL,\n        _ref3$parseURL = _ref3.parseURL,\n        parseURL = _ref3$parseURL === undefined ? defaultParseURL : _ref3$parseURL;\n\n    _classCallCheck(this, BrowserHistory);\n\n    this.windowTitle = windowTitle;\n    this.writeTimer = undefined;\n    this.writeDelay = writeDelay;\n    this._createURL = createURL;\n    this.parseURL = parseURL;\n  }\n  /**\n   * This method pushes a search state into the URL.\n   * @param {object} routeState a syncable UI state\n   * @return {undefined}\n   */\n\n\n  _createClass(BrowserHistory, [{\n    key: 'write',\n    value: function write(routeState) {\n      var _this = this;\n\n      var url = this.createURL(routeState);\n      var title = this.windowTitle && this.windowTitle(routeState);\n\n      if (this.writeTimer) {\n        window.clearTimeout(this.writeTimer);\n      }\n\n      this.writeTimer = setTimeout(function () {\n        if (title) window.document.title = title;\n        window.history.pushState(routeState, title || '', url);\n        _this.writeTimer = undefined;\n      }, this.writeDelay);\n    }\n    /**\n     * This methods read the URL and returns a syncable UI search state.\n     * @return {object} the equivalent to what is store in the URL as an object\n     */\n\n  }, {\n    key: 'read',\n    value: function read() {\n      return this.parseURL({\n        qsModule: qs,\n        location: window.location\n      });\n    }\n    /**\n     * This methods sets a callback on the `onpopstate` event of the history API\n     * of the current page. This way, the URL sync can keep track of the changes.\n     * @param {function(object)} cb the callback that will receive the latest routeState.\n     * It is called when the URL is updated.\n     * @returns {undefined}\n     */\n\n  }, {\n    key: 'onUpdate',\n    value: function onUpdate(cb) {\n      var _this2 = this;\n\n      this._onPopState = function (event) {\n        if (_this2.writeTimer) {\n          window.clearTimeout(_this2.writeTimer);\n          _this2.writeTimer = undefined;\n        }\n\n        var routeState = event.state; // at initial load, the state is read from the URL without\n        // update. Therefore the state object is not there. In this\n        // case we fallback and read the URL.\n\n        if (!routeState) {\n          cb(_this2.read());\n        } else {\n          cb(routeState);\n        }\n      };\n\n      window.addEventListener('popstate', this._onPopState);\n    }\n    /**\n     * This method creates a complete URL from a given syncable UI state.\n     *\n     * It always generates the full url, not a relative one.\n     * This way we can handle cases like using a <base href>, see\n     * https://github.com/algolia/instantsearch.js/issues/790 for the original issue\n     *\n     * @param {object} routeState a syncable UI state\n     * @returns {string} the full URL for the provided syncable state\n     */\n\n  }, {\n    key: 'createURL',\n    value: function createURL(routeState) {\n      return this._createURL({\n        qsModule: qs,\n        routeState: routeState,\n        location: window.location\n      });\n    }\n    /**\n     * This method removes the event listener and cleans up the URL.\n     * @returns {undefined}\n     */\n\n  }, {\n    key: 'dispose',\n    value: function dispose() {\n      window.removeEventListener('popstate', this._onPopState);\n      if (this.writeTimer) window.clearTimeout(this.writeTimer);\n      this.write();\n    }\n  }]);\n\n  return BrowserHistory;\n}();\n\nexport default function () {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return new (Function.prototype.bind.apply(BrowserHistory, [null].concat(args)))();\n}","map":{"version":3,"sources":["/home/sow/Bureau/ProjetPerso/Gestion_School/embryo-angular/node_modules/instantsearch.js/es/lib/routers/history.js"],"names":["_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","Constructor","protoProps","staticProps","prototype","_classCallCheck","instance","TypeError","qs","defaultCreateURL","_ref","qsModule","routeState","location","protocol","hostname","_location$port","port","undefined","pathname","hash","queryString","stringify","portWithPrefix","keys","defaultParseURL","_ref2","parse","search","slice","arrayLimit","BrowserHistory","_ref3","arguments","windowTitle","_ref3$writeDelay","writeDelay","_ref3$createURL","createURL","_ref3$parseURL","parseURL","writeTimer","_createURL","value","write","_this","url","title","window","clearTimeout","setTimeout","document","history","pushState","read","onUpdate","cb","_this2","_onPopState","event","state","addEventListener","dispose","removeEventListener","_len","args","Array","_key","Function","bind","apply","concat"],"mappings":"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","sourcesContent":["var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nimport qs from 'qs';\n\nfunction defaultCreateURL(_ref) {\n  var qsModule = _ref.qsModule,\n      routeState = _ref.routeState,\n      location = _ref.location;\n  var protocol = location.protocol,\n      hostname = location.hostname,\n      _location$port = location.port,\n      port = _location$port === undefined ? '' : _location$port,\n      pathname = location.pathname,\n      hash = location.hash;\n\n  var queryString = qsModule.stringify(routeState);\n  var portWithPrefix = port === '' ? '' : ':' + port;\n  // IE <= 11 has no location.origin or buggy. Therefore we don't rely on it\n  if (!routeState || Object.keys(routeState).length === 0) return protocol + '//' + hostname + portWithPrefix + pathname + hash;else return protocol + '//' + hostname + portWithPrefix + pathname + '?' + queryString + hash;\n}\n\nfunction defaultParseURL(_ref2) {\n  var qsModule = _ref2.qsModule,\n      location = _ref2.location;\n\n  // `qs` by default converts arrays with more than 20 items to an object.\n  // We want to avoid this because the data structure manipulated can therefore vary.\n  // Setting the limit to `100` seems a good number because the engine's default is 100\n  // (it can go up to 1000 but it is very unlikely to select more than 100 items in the UI).\n  //\n  // Using an `arrayLimit` of `n` allows `n + 1` items.\n  //\n  // See:\n  //   - https://github.com/ljharb/qs#parsing-arrays\n  //   - https://www.algolia.com/doc/api-reference/api-parameters/maxValuesPerFacet/\n  return qsModule.parse(location.search.slice(1), { arrayLimit: 99 });\n}\n\nvar BrowserHistory = function () {\n  /**\n   * Initializes a new storage provider that will sync the search state in the URL\n   * using web API (window.location.pushState and onpopstate event).\n   * @param {object} $0 the options.\n   * @param {function(object):string} [$0.windowTitle] function that transforms a UI state\n   * into a title for the page. It takes one parameter: a syncable object (generated by the mapping\n   * provided to the URL sync). It should return a string that will be the title.\n   * @param {number} [$0.writeDelay = 400] time before a write is actually done.\n   * Prevent having too much entries in the history and thus make the back button more friendly.\n   * @param {function(qs, object):string} [$0.createURL] generates the full URL. If not provided,\n   * the storage adaptor will mapped all syncable keys to the query string of the URL. The first\n   * parameter is a utility object that has two methods: `stringify` that creates a query string\n   * from an object and `parse` that transforms a query string into an object.\n   * @param {function(qs): object} [$0.parseURL] parses an URL into an object. It should symetrical\n   * to `createURL`. It gets as an argument an object that contains two methods: `stringify` that\n   * creates a query string from an object and `parse` that transforms a query string into an object.\n   */\n  function BrowserHistory() {\n    var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        windowTitle = _ref3.windowTitle,\n        _ref3$writeDelay = _ref3.writeDelay,\n        writeDelay = _ref3$writeDelay === undefined ? 400 : _ref3$writeDelay,\n        _ref3$createURL = _ref3.createURL,\n        createURL = _ref3$createURL === undefined ? defaultCreateURL : _ref3$createURL,\n        _ref3$parseURL = _ref3.parseURL,\n        parseURL = _ref3$parseURL === undefined ? defaultParseURL : _ref3$parseURL;\n\n    _classCallCheck(this, BrowserHistory);\n\n    this.windowTitle = windowTitle;\n    this.writeTimer = undefined;\n    this.writeDelay = writeDelay;\n    this._createURL = createURL;\n    this.parseURL = parseURL;\n  }\n\n  /**\n   * This method pushes a search state into the URL.\n   * @param {object} routeState a syncable UI state\n   * @return {undefined}\n   */\n\n\n  _createClass(BrowserHistory, [{\n    key: 'write',\n    value: function write(routeState) {\n      var _this = this;\n\n      var url = this.createURL(routeState);\n      var title = this.windowTitle && this.windowTitle(routeState);\n\n      if (this.writeTimer) {\n        window.clearTimeout(this.writeTimer);\n      }\n\n      this.writeTimer = setTimeout(function () {\n        if (title) window.document.title = title;\n        window.history.pushState(routeState, title || '', url);\n        _this.writeTimer = undefined;\n      }, this.writeDelay);\n    }\n\n    /**\n     * This methods read the URL and returns a syncable UI search state.\n     * @return {object} the equivalent to what is store in the URL as an object\n     */\n\n  }, {\n    key: 'read',\n    value: function read() {\n      return this.parseURL({ qsModule: qs, location: window.location });\n    }\n\n    /**\n     * This methods sets a callback on the `onpopstate` event of the history API\n     * of the current page. This way, the URL sync can keep track of the changes.\n     * @param {function(object)} cb the callback that will receive the latest routeState.\n     * It is called when the URL is updated.\n     * @returns {undefined}\n     */\n\n  }, {\n    key: 'onUpdate',\n    value: function onUpdate(cb) {\n      var _this2 = this;\n\n      this._onPopState = function (event) {\n        if (_this2.writeTimer) {\n          window.clearTimeout(_this2.writeTimer);\n          _this2.writeTimer = undefined;\n        }\n        var routeState = event.state;\n        // at initial load, the state is read from the URL without\n        // update. Therefore the state object is not there. In this\n        // case we fallback and read the URL.\n        if (!routeState) {\n          cb(_this2.read());\n        } else {\n          cb(routeState);\n        }\n      };\n      window.addEventListener('popstate', this._onPopState);\n    }\n\n    /**\n     * This method creates a complete URL from a given syncable UI state.\n     *\n     * It always generates the full url, not a relative one.\n     * This way we can handle cases like using a <base href>, see\n     * https://github.com/algolia/instantsearch.js/issues/790 for the original issue\n     *\n     * @param {object} routeState a syncable UI state\n     * @returns {string} the full URL for the provided syncable state\n     */\n\n  }, {\n    key: 'createURL',\n    value: function createURL(routeState) {\n      return this._createURL({\n        qsModule: qs,\n        routeState: routeState,\n        location: window.location\n      });\n    }\n\n    /**\n     * This method removes the event listener and cleans up the URL.\n     * @returns {undefined}\n     */\n\n  }, {\n    key: 'dispose',\n    value: function dispose() {\n      window.removeEventListener('popstate', this._onPopState);\n      if (this.writeTimer) window.clearTimeout(this.writeTimer);\n      this.write();\n    }\n  }]);\n\n  return BrowserHistory;\n}();\n\nexport default function () {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return new (Function.prototype.bind.apply(BrowserHistory, [null].concat(args)))();\n}"]},"metadata":{},"sourceType":"module"}