{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nimport find from 'lodash/find';\nimport _isFinite from 'lodash/isFinite';\nimport { checkRendering } from '../../lib/utils.js';\nvar usage = 'Usage:\\nvar customRange = connectRange(function render(params, isFirstRendering) {\\n  // params = {\\n  //   refine,\\n  //   range,\\n  //   start,\\n  //   format,\\n  //   instantSearchInstance,\\n  //   widgetParams,\\n  // }\\n});\\nsearch.addWidget(\\n  customRange({\\n    attributeName,\\n    [ min ],\\n    [ max ],\\n    [ precision = 2 ],\\n  })\\n);\\nFull documentation available at https://community.algolia.com/instantsearch.js/v2/connectors/connectRange.html\\n';\n/**\n * @typedef {Object} CustomRangeWidgetOptions\n * @property {string} attributeName Name of the attribute for faceting.\n * @property {number} [min = undefined] Minimal range value, default to automatically computed from the result set.\n * @property {number} [max = undefined] Maximal range value, default to automatically computed from the result set.\n * @property {number} [precision = 2] Number of digits after decimal point to use.\n */\n\n/**\n * @typedef {Object} RangeRenderingOptions\n * @property {function(Array<number, number>)} refine Sets a range to filter the results on. Both values\n * are optional, and will default to the higher and lower bounds. You can use `undefined` to remove a\n * previously set bound or to set an infinite bound.\n * @property {{min: number, max: number}} range Results bounds without the current range filter.\n * @property {Array<number, number>} start Current numeric bounds of the search.\n * @property {{from: function, to: function}} formatter Transform for the rendering `from` and/or `to` values.\n * Both functions take a `number` as input and should output a `string`.\n * @property {Object} widgetParams All original `CustomRangeWidgetOptions` forwarded to the `renderFn`.\n */\n\n/**\n * **Range** connector provides the logic to create custom widget that will let\n * the user refine results using a numeric range.\n *\n * This connectors provides a `refine()` function that accepts bounds. It will also provide\n * information about the min and max bounds for the current result set.\n * @type {Connector}\n * @canonical https://www.algolia.com/doc/api-reference/widgets/range-input/js/\n * @param {function(RangeRenderingOptions, boolean)} renderFn Rendering function for the custom **Range** widget.\n * @param {function} unmountFn Unmount function called when the widget is disposed.\n * @return {function(CustomRangeWidgetOptions)} Re-usable widget factory for a custom **Range** widget.\n */\n\nexport default function connectRange(renderFn, unmountFn) {\n  checkRendering(renderFn, usage);\n  return function () {\n    var widgetParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var attributeName = widgetParams.attributeName,\n        minBound = widgetParams.min,\n        maxBound = widgetParams.max,\n        _widgetParams$precisi = widgetParams.precision,\n        precision = _widgetParams$precisi === undefined ? 2 : _widgetParams$precisi;\n\n    if (!attributeName) {\n      throw new Error(usage);\n    }\n\n    var hasMinBound = _isFinite(minBound);\n\n    var hasMaxBound = _isFinite(maxBound);\n\n    var formatToNumber = function formatToNumber(v) {\n      return Number(Number(v).toFixed(precision));\n    };\n\n    var rangeFormatter = {\n      from: function from(v) {\n        return v;\n      },\n      to: function to(v) {\n        return formatToNumber(v).toLocaleString();\n      }\n    };\n    return {\n      _getCurrentRange: function _getCurrentRange(stats) {\n        var pow = Math.pow(10, precision);\n        var min = void 0;\n\n        if (hasMinBound) {\n          min = minBound;\n        } else if (_isFinite(stats.min)) {\n          min = stats.min;\n        } else {\n          min = 0;\n        }\n\n        var max = void 0;\n\n        if (hasMaxBound) {\n          max = maxBound;\n        } else if (_isFinite(stats.max)) {\n          max = stats.max;\n        } else {\n          max = 0;\n        }\n\n        return {\n          min: Math.floor(min * pow) / pow,\n          max: Math.ceil(max * pow) / pow\n        };\n      },\n      _getCurrentRefinement: function _getCurrentRefinement(helper) {\n        var _ref = helper.getNumericRefinement(attributeName, '>=') || [],\n            _ref2 = _slicedToArray(_ref, 1),\n            minValue = _ref2[0];\n\n        var _ref3 = helper.getNumericRefinement(attributeName, '<=') || [],\n            _ref4 = _slicedToArray(_ref3, 1),\n            maxValue = _ref4[0];\n\n        var min = _isFinite(minValue) ? minValue : -Infinity;\n        var max = _isFinite(maxValue) ? maxValue : Infinity;\n        return [min, max];\n      },\n      _refine: function _refine(helper, currentRange) {\n        // eslint-disable-next-line complexity\n        return function () {\n          var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [],\n              _ref6 = _slicedToArray(_ref5, 2),\n              nextMin = _ref6[0],\n              nextMax = _ref6[1];\n\n          var currentRangeMin = currentRange.min,\n              currentRangeMax = currentRange.max;\n\n          var _ref7 = helper.getNumericRefinement(attributeName, '>=') || [],\n              _ref8 = _slicedToArray(_ref7, 1),\n              min = _ref8[0];\n\n          var _ref9 = helper.getNumericRefinement(attributeName, '<=') || [],\n              _ref10 = _slicedToArray(_ref9, 1),\n              max = _ref10[0];\n\n          var isResetMin = nextMin === undefined || nextMin === '';\n          var isResetMax = nextMax === undefined || nextMax === '';\n          var nextMinAsNumber = !isResetMin ? parseFloat(nextMin) : undefined;\n          var nextMaxAsNumber = !isResetMax ? parseFloat(nextMax) : undefined;\n          var newNextMin = void 0;\n\n          if (!hasMinBound && currentRangeMin === nextMinAsNumber) {\n            newNextMin = undefined;\n          } else if (hasMinBound && isResetMin) {\n            newNextMin = minBound;\n          } else {\n            newNextMin = nextMinAsNumber;\n          }\n\n          var newNextMax = void 0;\n\n          if (!hasMaxBound && currentRangeMax === nextMaxAsNumber) {\n            newNextMax = undefined;\n          } else if (hasMaxBound && isResetMax) {\n            newNextMax = maxBound;\n          } else {\n            newNextMax = nextMaxAsNumber;\n          }\n\n          var isResetNewNextMin = newNextMin === undefined;\n\n          var isValidNewNextMin = _isFinite(newNextMin);\n\n          var isValidMinCurrentRange = _isFinite(currentRangeMin);\n\n          var isGreaterThanCurrentRange = isValidMinCurrentRange && currentRangeMin <= newNextMin;\n          var isMinValid = isResetNewNextMin || isValidNewNextMin && (!isValidMinCurrentRange || isGreaterThanCurrentRange);\n          var isResetNewNextMax = newNextMax === undefined;\n\n          var isValidNewNextMax = _isFinite(newNextMax);\n\n          var isValidMaxCurrentRange = _isFinite(currentRangeMax);\n\n          var isLowerThanRange = isValidMaxCurrentRange && currentRangeMax >= newNextMax;\n          var isMaxValid = isResetNewNextMax || isValidNewNextMax && (!isValidMaxCurrentRange || isLowerThanRange);\n          var hasMinChange = min !== newNextMin;\n          var hasMaxChange = max !== newNextMax;\n\n          if ((hasMinChange || hasMaxChange) && isMinValid && isMaxValid) {\n            helper.clearRefinements(attributeName);\n\n            if (isValidNewNextMin) {\n              helper.addNumericRefinement(attributeName, '>=', formatToNumber(newNextMin));\n            }\n\n            if (isValidNewNextMax) {\n              helper.addNumericRefinement(attributeName, '<=', formatToNumber(newNextMax));\n            }\n\n            helper.search();\n          }\n        };\n      },\n      getConfiguration: function getConfiguration(currentConfiguration) {\n        var configuration = {\n          disjunctiveFacets: [attributeName]\n        };\n        var isBoundsDefined = hasMinBound || hasMaxBound;\n        var boundsAlreadyDefined = currentConfiguration && currentConfiguration.numericRefinements && currentConfiguration.numericRefinements[attributeName] !== undefined;\n\n        var isMinBoundValid = _isFinite(minBound);\n\n        var isMaxBoundValid = _isFinite(maxBound);\n\n        var isAbleToRefine = isMinBoundValid && isMaxBoundValid ? minBound < maxBound : isMinBoundValid || isMaxBoundValid;\n\n        if (isBoundsDefined && !boundsAlreadyDefined && isAbleToRefine) {\n          configuration.numericRefinements = _defineProperty({}, attributeName, {});\n\n          if (hasMinBound) {\n            configuration.numericRefinements[attributeName]['>='] = [minBound];\n          }\n\n          if (hasMaxBound) {\n            configuration.numericRefinements[attributeName]['<='] = [maxBound];\n          }\n        }\n\n        return configuration;\n      },\n      init: function init(_ref11) {\n        var helper = _ref11.helper,\n            instantSearchInstance = _ref11.instantSearchInstance;\n        var stats = {};\n\n        var currentRange = this._getCurrentRange(stats);\n\n        var start = this._getCurrentRefinement(helper);\n\n        renderFn({\n          // On first render pass an empty range\n          // to be able to bypass the validation\n          // related to it\n          refine: this._refine(helper, {}),\n          format: rangeFormatter,\n          range: currentRange,\n          widgetParams: _extends({}, widgetParams, {\n            precision: precision\n          }),\n          start: start,\n          instantSearchInstance: instantSearchInstance\n        }, true);\n      },\n      render: function render(_ref12) {\n        var results = _ref12.results,\n            helper = _ref12.helper,\n            instantSearchInstance = _ref12.instantSearchInstance;\n        var facetsFromResults = results.disjunctiveFacets || [];\n        var facet = find(facetsFromResults, {\n          name: attributeName\n        });\n        var stats = facet && facet.stats || {};\n\n        var currentRange = this._getCurrentRange(stats);\n\n        var start = this._getCurrentRefinement(helper);\n\n        renderFn({\n          refine: this._refine(helper, currentRange),\n          format: rangeFormatter,\n          range: currentRange,\n          widgetParams: _extends({}, widgetParams, {\n            precision: precision\n          }),\n          start: start,\n          instantSearchInstance: instantSearchInstance\n        }, false);\n      },\n      dispose: function dispose(_ref13) {\n        var state = _ref13.state;\n        unmountFn();\n        var nextState = state.removeNumericRefinement(attributeName).removeDisjunctiveFacet(attributeName);\n        return nextState;\n      },\n      getWidgetState: function getWidgetState(uiState, _ref14) {\n        var searchParameters = _ref14.searchParameters;\n\n        var _searchParameters$get = searchParameters.getNumericRefinements(attributeName),\n            _searchParameters$get2 = _searchParameters$get['>='],\n            min = _searchParameters$get2 === undefined ? '' : _searchParameters$get2,\n            _searchParameters$get3 = _searchParameters$get['<='],\n            max = _searchParameters$get3 === undefined ? '' : _searchParameters$get3;\n\n        if (min === '' && max === '' || uiState && uiState.range && uiState.range[attributeName] === min + ':' + max) {\n          return uiState;\n        }\n\n        return _extends({}, uiState, {\n          range: _extends({}, uiState.range, _defineProperty({}, attributeName, min + ':' + max))\n        });\n      },\n      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref15) {\n        var uiState = _ref15.uiState;\n        var value = uiState && uiState.range && uiState.range[attributeName];\n\n        if (!value || value.indexOf(':') === -1) {\n          return searchParameters;\n        }\n\n        var _searchParameters$get4 = searchParameters.getNumericRefinements(attributeName),\n            _searchParameters$get5 = _searchParameters$get4['>='],\n            previousMin = _searchParameters$get5 === undefined ? [NaN] : _searchParameters$get5,\n            _searchParameters$get6 = _searchParameters$get4['<='],\n            previousMax = _searchParameters$get6 === undefined ? [NaN] : _searchParameters$get6;\n\n        var clearedParams = searchParameters.clearRefinements(attributeName);\n\n        var _value$split$map = value.split(':').map(parseFloat),\n            _value$split$map2 = _slicedToArray(_value$split$map, 2),\n            lowerBound = _value$split$map2[0],\n            upperBound = _value$split$map2[1];\n\n        if (previousMin.includes(lowerBound) && previousMax.includes(upperBound)) {\n          return searchParameters;\n        }\n\n        if (_isFinite(lowerBound)) {\n          clearedParams = clearedParams.addNumericRefinement(attributeName, '>=', lowerBound);\n        }\n\n        if (_isFinite(upperBound)) {\n          clearedParams = clearedParams.addNumericRefinement(attributeName, '<=', upperBound);\n        }\n\n        return clearedParams;\n      }\n    };\n  };\n}","map":{"version":3,"sources":["/home/sow/Bureau/ProjetPerso/Gestion_School/embryo-angular/node_modules/instantsearch.js/es/connectors/range/connectRange.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","_slicedToArray","sliceIterator","arr","_arr","_n","_d","_e","undefined","_i","Symbol","iterator","_s","next","done","push","value","err","Array","isArray","TypeError","_defineProperty","obj","defineProperty","enumerable","configurable","writable","find","_isFinite","checkRendering","usage","connectRange","renderFn","unmountFn","widgetParams","attributeName","minBound","min","maxBound","max","_widgetParams$precisi","precision","Error","hasMinBound","hasMaxBound","formatToNumber","v","Number","toFixed","rangeFormatter","from","to","toLocaleString","_getCurrentRange","stats","pow","Math","floor","ceil","_getCurrentRefinement","helper","_ref","getNumericRefinement","_ref2","minValue","_ref3","_ref4","maxValue","Infinity","_refine","currentRange","_ref5","_ref6","nextMin","nextMax","currentRangeMin","currentRangeMax","_ref7","_ref8","_ref9","_ref10","isResetMin","isResetMax","nextMinAsNumber","parseFloat","nextMaxAsNumber","newNextMin","newNextMax","isResetNewNextMin","isValidNewNextMin","isValidMinCurrentRange","isGreaterThanCurrentRange","isMinValid","isResetNewNextMax","isValidNewNextMax","isValidMaxCurrentRange","isLowerThanRange","isMaxValid","hasMinChange","hasMaxChange","clearRefinements","addNumericRefinement","search","getConfiguration","currentConfiguration","configuration","disjunctiveFacets","isBoundsDefined","boundsAlreadyDefined","numericRefinements","isMinBoundValid","isMaxBoundValid","isAbleToRefine","init","_ref11","instantSearchInstance","start","refine","format","range","render","_ref12","results","facetsFromResults","facet","name","dispose","_ref13","state","nextState","removeNumericRefinement","removeDisjunctiveFacet","getWidgetState","uiState","_ref14","searchParameters","_searchParameters$get","getNumericRefinements","_searchParameters$get2","_searchParameters$get3","getWidgetSearchParameters","_ref15","indexOf","_searchParameters$get4","_searchParameters$get5","previousMin","NaN","_searchParameters$get6","previousMax","clearedParams","_value$split$map","split","map","_value$split$map2","lowerBound","upperBound","includes"],"mappings":"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","sourcesContent":["var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport find from 'lodash/find';\nimport _isFinite from 'lodash/isFinite';\n\nimport { checkRendering } from '../../lib/utils.js';\n\nvar usage = 'Usage:\\nvar customRange = connectRange(function render(params, isFirstRendering) {\\n  // params = {\\n  //   refine,\\n  //   range,\\n  //   start,\\n  //   format,\\n  //   instantSearchInstance,\\n  //   widgetParams,\\n  // }\\n});\\nsearch.addWidget(\\n  customRange({\\n    attributeName,\\n    [ min ],\\n    [ max ],\\n    [ precision = 2 ],\\n  })\\n);\\nFull documentation available at https://community.algolia.com/instantsearch.js/v2/connectors/connectRange.html\\n';\n\n/**\n * @typedef {Object} CustomRangeWidgetOptions\n * @property {string} attributeName Name of the attribute for faceting.\n * @property {number} [min = undefined] Minimal range value, default to automatically computed from the result set.\n * @property {number} [max = undefined] Maximal range value, default to automatically computed from the result set.\n * @property {number} [precision = 2] Number of digits after decimal point to use.\n */\n\n/**\n * @typedef {Object} RangeRenderingOptions\n * @property {function(Array<number, number>)} refine Sets a range to filter the results on. Both values\n * are optional, and will default to the higher and lower bounds. You can use `undefined` to remove a\n * previously set bound or to set an infinite bound.\n * @property {{min: number, max: number}} range Results bounds without the current range filter.\n * @property {Array<number, number>} start Current numeric bounds of the search.\n * @property {{from: function, to: function}} formatter Transform for the rendering `from` and/or `to` values.\n * Both functions take a `number` as input and should output a `string`.\n * @property {Object} widgetParams All original `CustomRangeWidgetOptions` forwarded to the `renderFn`.\n */\n\n/**\n * **Range** connector provides the logic to create custom widget that will let\n * the user refine results using a numeric range.\n *\n * This connectors provides a `refine()` function that accepts bounds. It will also provide\n * information about the min and max bounds for the current result set.\n * @type {Connector}\n * @canonical https://www.algolia.com/doc/api-reference/widgets/range-input/js/\n * @param {function(RangeRenderingOptions, boolean)} renderFn Rendering function for the custom **Range** widget.\n * @param {function} unmountFn Unmount function called when the widget is disposed.\n * @return {function(CustomRangeWidgetOptions)} Re-usable widget factory for a custom **Range** widget.\n */\nexport default function connectRange(renderFn, unmountFn) {\n  checkRendering(renderFn, usage);\n\n  return function () {\n    var widgetParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var attributeName = widgetParams.attributeName,\n        minBound = widgetParams.min,\n        maxBound = widgetParams.max,\n        _widgetParams$precisi = widgetParams.precision,\n        precision = _widgetParams$precisi === undefined ? 2 : _widgetParams$precisi;\n\n\n    if (!attributeName) {\n      throw new Error(usage);\n    }\n\n    var hasMinBound = _isFinite(minBound);\n    var hasMaxBound = _isFinite(maxBound);\n\n    var formatToNumber = function formatToNumber(v) {\n      return Number(Number(v).toFixed(precision));\n    };\n\n    var rangeFormatter = {\n      from: function from(v) {\n        return v;\n      },\n      to: function to(v) {\n        return formatToNumber(v).toLocaleString();\n      }\n    };\n\n    return {\n      _getCurrentRange: function _getCurrentRange(stats) {\n        var pow = Math.pow(10, precision);\n\n        var min = void 0;\n        if (hasMinBound) {\n          min = minBound;\n        } else if (_isFinite(stats.min)) {\n          min = stats.min;\n        } else {\n          min = 0;\n        }\n\n        var max = void 0;\n        if (hasMaxBound) {\n          max = maxBound;\n        } else if (_isFinite(stats.max)) {\n          max = stats.max;\n        } else {\n          max = 0;\n        }\n\n        return {\n          min: Math.floor(min * pow) / pow,\n          max: Math.ceil(max * pow) / pow\n        };\n      },\n      _getCurrentRefinement: function _getCurrentRefinement(helper) {\n        var _ref = helper.getNumericRefinement(attributeName, '>=') || [],\n            _ref2 = _slicedToArray(_ref, 1),\n            minValue = _ref2[0];\n\n        var _ref3 = helper.getNumericRefinement(attributeName, '<=') || [],\n            _ref4 = _slicedToArray(_ref3, 1),\n            maxValue = _ref4[0];\n\n        var min = _isFinite(minValue) ? minValue : -Infinity;\n        var max = _isFinite(maxValue) ? maxValue : Infinity;\n\n        return [min, max];\n      },\n      _refine: function _refine(helper, currentRange) {\n        // eslint-disable-next-line complexity\n        return function () {\n          var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [],\n              _ref6 = _slicedToArray(_ref5, 2),\n              nextMin = _ref6[0],\n              nextMax = _ref6[1];\n\n          var currentRangeMin = currentRange.min,\n              currentRangeMax = currentRange.max;\n\n          var _ref7 = helper.getNumericRefinement(attributeName, '>=') || [],\n              _ref8 = _slicedToArray(_ref7, 1),\n              min = _ref8[0];\n\n          var _ref9 = helper.getNumericRefinement(attributeName, '<=') || [],\n              _ref10 = _slicedToArray(_ref9, 1),\n              max = _ref10[0];\n\n          var isResetMin = nextMin === undefined || nextMin === '';\n          var isResetMax = nextMax === undefined || nextMax === '';\n\n          var nextMinAsNumber = !isResetMin ? parseFloat(nextMin) : undefined;\n          var nextMaxAsNumber = !isResetMax ? parseFloat(nextMax) : undefined;\n\n          var newNextMin = void 0;\n          if (!hasMinBound && currentRangeMin === nextMinAsNumber) {\n            newNextMin = undefined;\n          } else if (hasMinBound && isResetMin) {\n            newNextMin = minBound;\n          } else {\n            newNextMin = nextMinAsNumber;\n          }\n\n          var newNextMax = void 0;\n          if (!hasMaxBound && currentRangeMax === nextMaxAsNumber) {\n            newNextMax = undefined;\n          } else if (hasMaxBound && isResetMax) {\n            newNextMax = maxBound;\n          } else {\n            newNextMax = nextMaxAsNumber;\n          }\n\n          var isResetNewNextMin = newNextMin === undefined;\n          var isValidNewNextMin = _isFinite(newNextMin);\n          var isValidMinCurrentRange = _isFinite(currentRangeMin);\n          var isGreaterThanCurrentRange = isValidMinCurrentRange && currentRangeMin <= newNextMin;\n          var isMinValid = isResetNewNextMin || isValidNewNextMin && (!isValidMinCurrentRange || isGreaterThanCurrentRange);\n\n          var isResetNewNextMax = newNextMax === undefined;\n          var isValidNewNextMax = _isFinite(newNextMax);\n          var isValidMaxCurrentRange = _isFinite(currentRangeMax);\n          var isLowerThanRange = isValidMaxCurrentRange && currentRangeMax >= newNextMax;\n          var isMaxValid = isResetNewNextMax || isValidNewNextMax && (!isValidMaxCurrentRange || isLowerThanRange);\n\n          var hasMinChange = min !== newNextMin;\n          var hasMaxChange = max !== newNextMax;\n\n          if ((hasMinChange || hasMaxChange) && isMinValid && isMaxValid) {\n            helper.clearRefinements(attributeName);\n\n            if (isValidNewNextMin) {\n              helper.addNumericRefinement(attributeName, '>=', formatToNumber(newNextMin));\n            }\n\n            if (isValidNewNextMax) {\n              helper.addNumericRefinement(attributeName, '<=', formatToNumber(newNextMax));\n            }\n\n            helper.search();\n          }\n        };\n      },\n      getConfiguration: function getConfiguration(currentConfiguration) {\n        var configuration = {\n          disjunctiveFacets: [attributeName]\n        };\n\n        var isBoundsDefined = hasMinBound || hasMaxBound;\n\n        var boundsAlreadyDefined = currentConfiguration && currentConfiguration.numericRefinements && currentConfiguration.numericRefinements[attributeName] !== undefined;\n\n        var isMinBoundValid = _isFinite(minBound);\n        var isMaxBoundValid = _isFinite(maxBound);\n        var isAbleToRefine = isMinBoundValid && isMaxBoundValid ? minBound < maxBound : isMinBoundValid || isMaxBoundValid;\n\n        if (isBoundsDefined && !boundsAlreadyDefined && isAbleToRefine) {\n          configuration.numericRefinements = _defineProperty({}, attributeName, {});\n\n          if (hasMinBound) {\n            configuration.numericRefinements[attributeName]['>='] = [minBound];\n          }\n\n          if (hasMaxBound) {\n            configuration.numericRefinements[attributeName]['<='] = [maxBound];\n          }\n        }\n\n        return configuration;\n      },\n      init: function init(_ref11) {\n        var helper = _ref11.helper,\n            instantSearchInstance = _ref11.instantSearchInstance;\n\n        var stats = {};\n        var currentRange = this._getCurrentRange(stats);\n        var start = this._getCurrentRefinement(helper);\n\n        renderFn({\n          // On first render pass an empty range\n          // to be able to bypass the validation\n          // related to it\n          refine: this._refine(helper, {}),\n          format: rangeFormatter,\n          range: currentRange,\n          widgetParams: _extends({}, widgetParams, {\n            precision: precision\n          }),\n          start: start,\n          instantSearchInstance: instantSearchInstance\n        }, true);\n      },\n      render: function render(_ref12) {\n        var results = _ref12.results,\n            helper = _ref12.helper,\n            instantSearchInstance = _ref12.instantSearchInstance;\n\n        var facetsFromResults = results.disjunctiveFacets || [];\n        var facet = find(facetsFromResults, { name: attributeName });\n        var stats = facet && facet.stats || {};\n\n        var currentRange = this._getCurrentRange(stats);\n        var start = this._getCurrentRefinement(helper);\n\n        renderFn({\n          refine: this._refine(helper, currentRange),\n          format: rangeFormatter,\n          range: currentRange,\n          widgetParams: _extends({}, widgetParams, {\n            precision: precision\n          }),\n          start: start,\n          instantSearchInstance: instantSearchInstance\n        }, false);\n      },\n      dispose: function dispose(_ref13) {\n        var state = _ref13.state;\n\n        unmountFn();\n\n        var nextState = state.removeNumericRefinement(attributeName).removeDisjunctiveFacet(attributeName);\n\n        return nextState;\n      },\n      getWidgetState: function getWidgetState(uiState, _ref14) {\n        var searchParameters = _ref14.searchParameters;\n\n        var _searchParameters$get = searchParameters.getNumericRefinements(attributeName),\n            _searchParameters$get2 = _searchParameters$get['>='],\n            min = _searchParameters$get2 === undefined ? '' : _searchParameters$get2,\n            _searchParameters$get3 = _searchParameters$get['<='],\n            max = _searchParameters$get3 === undefined ? '' : _searchParameters$get3;\n\n        if (min === '' && max === '' || uiState && uiState.range && uiState.range[attributeName] === min + ':' + max) {\n          return uiState;\n        }\n\n        return _extends({}, uiState, {\n          range: _extends({}, uiState.range, _defineProperty({}, attributeName, min + ':' + max))\n        });\n      },\n      getWidgetSearchParameters: function getWidgetSearchParameters(searchParameters, _ref15) {\n        var uiState = _ref15.uiState;\n\n        var value = uiState && uiState.range && uiState.range[attributeName];\n\n        if (!value || value.indexOf(':') === -1) {\n          return searchParameters;\n        }\n\n        var _searchParameters$get4 = searchParameters.getNumericRefinements(attributeName),\n            _searchParameters$get5 = _searchParameters$get4['>='],\n            previousMin = _searchParameters$get5 === undefined ? [NaN] : _searchParameters$get5,\n            _searchParameters$get6 = _searchParameters$get4['<='],\n            previousMax = _searchParameters$get6 === undefined ? [NaN] : _searchParameters$get6;\n\n        var clearedParams = searchParameters.clearRefinements(attributeName);\n\n        var _value$split$map = value.split(':').map(parseFloat),\n            _value$split$map2 = _slicedToArray(_value$split$map, 2),\n            lowerBound = _value$split$map2[0],\n            upperBound = _value$split$map2[1];\n\n        if (previousMin.includes(lowerBound) && previousMax.includes(upperBound)) {\n          return searchParameters;\n        }\n\n        if (_isFinite(lowerBound)) {\n          clearedParams = clearedParams.addNumericRefinement(attributeName, '>=', lowerBound);\n        }\n\n        if (_isFinite(upperBound)) {\n          clearedParams = clearedParams.addNumericRefinement(attributeName, '<=', upperBound);\n        }\n\n        return clearedParams;\n      }\n    };\n  };\n}"]},"metadata":{},"sourceType":"module"}