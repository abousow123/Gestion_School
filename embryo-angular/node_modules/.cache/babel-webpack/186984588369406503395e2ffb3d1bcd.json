{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nimport isFunction from 'lodash/isFunction';\nimport isPlainObject from 'lodash/isPlainObject';\nimport { enhanceConfiguration } from '../../lib/InstantSearch.js';\nvar usage = 'Usage:\\nvar customConfigureWidget = connectConfigure(\\n  function renderFn(params, isFirstRendering) {\\n    // params = {\\n    //   refine,\\n    //   widgetParams\\n    // }\\n  },\\n  function disposeFn() {}\\n)\\n';\n/**\n * @typedef {Object} CustomConfigureWidgetOptions\n * @property {Object} searchParameters The Configure widget options are search parameters\n */\n\n/**\n * @typedef {Object} ConfigureRenderingOptions\n * @property {function(searchParameters: Object)} refine Sets new `searchParameters` and trigger a search.\n * @property {Object} widgetParams All original `CustomConfigureWidgetOptions` forwarded to the `renderFn`.\n */\n\n/**\n * The **Configure** connector provides the logic to build a custom widget\n * that will give you ability to override or force some search parameters sent to Algolia API.\n *\n * @type {Connector}\n * @canonical https://www.algolia.com/doc/api-reference/widgets/configure/js/\n * @param {function(ConfigureRenderingOptions)} renderFn Rendering function for the custom **Configure** Widget.\n * @param {function} unmountFn Unmount function called when the widget is disposed.\n * @return {function(CustomConfigureWidgetOptions)} Re-usable widget factory for a custom **Configure** widget.\n */\n\nexport default function connectConfigure(renderFn, unmountFn) {\n  if (isFunction(renderFn) && !isFunction(unmountFn) || !isFunction(renderFn) && isFunction(unmountFn)) {\n    throw new Error(usage);\n  }\n\n  return function () {\n    var widgetParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!isPlainObject(widgetParams.searchParameters)) {\n      throw new Error(usage);\n    }\n\n    return {\n      getConfiguration: function getConfiguration() {\n        return widgetParams.searchParameters;\n      },\n      init: function init(_ref) {\n        var helper = _ref.helper;\n        this._refine = this.refine(helper);\n\n        if (isFunction(renderFn)) {\n          renderFn({\n            refine: this._refine,\n            widgetParams: widgetParams\n          }, true);\n        }\n      },\n      refine: function refine(helper) {\n        var _this = this;\n\n        return function (searchParameters) {\n          // merge new `searchParameters` with the ones set from other widgets\n          var actualState = _this.removeSearchParameters(helper.getState());\n\n          var nextSearchParameters = enhanceConfiguration({})(_extends({}, actualState), {\n            getConfiguration: function getConfiguration() {\n              return searchParameters;\n            }\n          }); // trigger a search with the new merged searchParameters\n\n          helper.setState(nextSearchParameters).search(); // update original `widgetParams.searchParameters` to the new refined one\n\n          widgetParams.searchParameters = searchParameters;\n        };\n      },\n      render: function render() {\n        if (renderFn) {\n          renderFn({\n            refine: this._refine,\n            widgetParams: widgetParams\n          }, false);\n        }\n      },\n      dispose: function dispose(_ref2) {\n        var state = _ref2.state;\n        if (unmountFn) unmountFn();\n        return this.removeSearchParameters(state);\n      },\n      removeSearchParameters: function removeSearchParameters(state) {\n        // widgetParams are assumed 'controlled',\n        // so they override whatever other widgets give the state\n        return state.mutateMe(function (mutableState) {\n          Object.keys(widgetParams.searchParameters).forEach(function (key) {\n            delete mutableState[key];\n          });\n        });\n      }\n    };\n  };\n}","map":{"version":3,"sources":["/home/sow/Bureau/ProjetPerso/Gestion_School/embryo-angular/node_modules/instantsearch.js/es/connectors/configure/connectConfigure.js"],"names":["_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","isFunction","isPlainObject","enhanceConfiguration","usage","connectConfigure","renderFn","unmountFn","Error","widgetParams","undefined","searchParameters","getConfiguration","init","_ref","helper","_refine","refine","_this","actualState","removeSearchParameters","getState","nextSearchParameters","setState","search","render","dispose","_ref2","state","mutateMe","mutableState","keys","forEach"],"mappings":"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","sourcesContent":["var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nimport isFunction from 'lodash/isFunction';\nimport isPlainObject from 'lodash/isPlainObject';\n\nimport { enhanceConfiguration } from '../../lib/InstantSearch.js';\n\nvar usage = 'Usage:\\nvar customConfigureWidget = connectConfigure(\\n  function renderFn(params, isFirstRendering) {\\n    // params = {\\n    //   refine,\\n    //   widgetParams\\n    // }\\n  },\\n  function disposeFn() {}\\n)\\n';\n\n/**\n * @typedef {Object} CustomConfigureWidgetOptions\n * @property {Object} searchParameters The Configure widget options are search parameters\n */\n\n/**\n * @typedef {Object} ConfigureRenderingOptions\n * @property {function(searchParameters: Object)} refine Sets new `searchParameters` and trigger a search.\n * @property {Object} widgetParams All original `CustomConfigureWidgetOptions` forwarded to the `renderFn`.\n */\n\n/**\n * The **Configure** connector provides the logic to build a custom widget\n * that will give you ability to override or force some search parameters sent to Algolia API.\n *\n * @type {Connector}\n * @canonical https://www.algolia.com/doc/api-reference/widgets/configure/js/\n * @param {function(ConfigureRenderingOptions)} renderFn Rendering function for the custom **Configure** Widget.\n * @param {function} unmountFn Unmount function called when the widget is disposed.\n * @return {function(CustomConfigureWidgetOptions)} Re-usable widget factory for a custom **Configure** widget.\n */\nexport default function connectConfigure(renderFn, unmountFn) {\n  if (isFunction(renderFn) && !isFunction(unmountFn) || !isFunction(renderFn) && isFunction(unmountFn)) {\n    throw new Error(usage);\n  }\n\n  return function () {\n    var widgetParams = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!isPlainObject(widgetParams.searchParameters)) {\n      throw new Error(usage);\n    }\n\n    return {\n      getConfiguration: function getConfiguration() {\n        return widgetParams.searchParameters;\n      },\n      init: function init(_ref) {\n        var helper = _ref.helper;\n\n        this._refine = this.refine(helper);\n\n        if (isFunction(renderFn)) {\n          renderFn({\n            refine: this._refine,\n            widgetParams: widgetParams\n          }, true);\n        }\n      },\n      refine: function refine(helper) {\n        var _this = this;\n\n        return function (searchParameters) {\n          // merge new `searchParameters` with the ones set from other widgets\n          var actualState = _this.removeSearchParameters(helper.getState());\n          var nextSearchParameters = enhanceConfiguration({})(_extends({}, actualState), {\n            getConfiguration: function getConfiguration() {\n              return searchParameters;\n            }\n          });\n\n          // trigger a search with the new merged searchParameters\n          helper.setState(nextSearchParameters).search();\n\n          // update original `widgetParams.searchParameters` to the new refined one\n          widgetParams.searchParameters = searchParameters;\n        };\n      },\n      render: function render() {\n        if (renderFn) {\n          renderFn({\n            refine: this._refine,\n            widgetParams: widgetParams\n          }, false);\n        }\n      },\n      dispose: function dispose(_ref2) {\n        var state = _ref2.state;\n\n        if (unmountFn) unmountFn();\n        return this.removeSearchParameters(state);\n      },\n      removeSearchParameters: function removeSearchParameters(state) {\n        // widgetParams are assumed 'controlled',\n        // so they override whatever other widgets give the state\n        return state.mutateMe(function (mutableState) {\n          Object.keys(widgetParams.searchParameters).forEach(function (key) {\n            delete mutableState[key];\n          });\n        });\n      }\n    };\n  };\n}"]},"metadata":{},"sourceType":"module"}